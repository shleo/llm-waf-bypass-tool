"""
AutoPentest - 主程序入口

自动化渗透测试工具，支持多种漏洞类型检测
"""
import argparse
import sys
import os
from typing import List, Dict, Any
from datetime import datetime

# 添加项目根目录到 Python 路径
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from core import Requester, PoCRecorder
from analyzers import SQLInjectionAnalyzer
from reporters import JSONReporter, HTMLReporter
from llm import LLMClient
from config import Settings
from utils import setup_logger, ensure_url, normalize_url


class AutoPentest:
    """
    AutoPentest 主类
    """

    def __init__(self, target: str, config: Settings = None):
        """
        初始化 AutoPentest

        Args:
            target: 目标 URL
            config: 配置对象
        """
        # 规范化目标 URL
        self.target = normalize_url(target)
        self.config = config or Settings()

        # 设置日志
        self.logger = setup_logger(
            level=self.config.LOG_LEVEL,
            log_file=self.config.LOG_FILE
        )

        # 初始化核心组件
        self.requester = Requester(
            timeout=self.config.DEFAULT_TIMEOUT,
            max_retries=self.config.DEFAULT_MAX_RETRIES,
            user_agent=self.config.DEFAULT_USER_AGENT,
            proxy=self.config.PROXY if self.config.PROXY else None
        )

        self.poc_recorder = PoCRecorder()

        # 初始化 LLM 客户端（如果启用）
        self.llm_client = None
        if self.config.ENABLE_LLM_ANALYSIS:
            llm_config = self.config.get_llm_config()
            if llm_config['api_key']:
                try:
                    self.llm_client = LLMClient(**llm_config)
                    self.logger.info("LLM client initialized successfully")
                except Exception as e:
                    self.logger.warning(f"Failed to initialize LLM client: {e}")

        # 初始化分析器
        self.analyzers = {
            'sqli': SQLInjectionAnalyzer(
                target=self.target,
                requester=self.requester,
                poc_recorder=self.poc_recorder,
                llm_client=self.llm_client,
                logger=self.logger
            )
        }

    def scan_endpoint(self, endpoint: str, method: str = 'GET',
                     params: Dict[str, str] = None,
                     data: Dict[str, str] = None,
                     analyzers: List[str] = None) -> List[Dict[str, Any]]:
        """
        扫描指定端点

        Args:
            endpoint: 目标端点 URL
            method: HTTP 方法
            params: URL 参数
            data: 请求体数据
            analyzers: 要使用的分析器列表（默认使用所有）

        Returns:
            发现的漏洞列表
        """
        self.logger.info(f"Scanning endpoint: {endpoint} ({method})")

        # 确定要使用的分析器
        if analyzers is None:
            analyzers = ['sqli']  # MVP 版本只支持 SQL 注入

        vulnerabilities = []

        # 运行每个分析器
        for analyzer_name in analyzers:
            if analyzer_name not in self.analyzers:
                self.logger.warning(f"Unknown analyzer: {analyzer_name}")
                continue

            analyzer = self.analyzers[analyzer_name]
            self.logger.info(f"Running {analyzer_name} analyzer...")

            try:
                results = analyzer.analyze(
                    endpoint=endpoint,
                    method=method,
                    params=params,
                    data=data
                )
                vulnerabilities.extend(results)

            except Exception as e:
                self.logger.error(f"{analyzer_name} analyzer failed: {e}")

        return vulnerabilities

    def scan_with_test_endpoints(self, base_url: str = None,
                                analyzers: List[str] = None) -> List[Dict[str, Any]]:
        """
        使用常见测试端点进行扫描

        Args:
            base_url: 基础 URL（默认使用目标 URL）
            analyzers: 要使用的分析器列表

        Returns:
            发现的漏洞列表
        """
        base_url = base_url or self.target
        self.logger.info(f"Starting scan with test endpoints on {base_url}")

        vulnerabilities = []

        # 遍历常见端点
        for endpoint_path in self.config.COMMON_TEST_ENDPOINTS:
            full_url = f"{base_url.rstrip('/')}{endpoint_path}"

            # 为每个端点生成测试参数
            for param in self.config.COMMON_TEST_PARAMS[:3]:  # 限制参数数量
                test_params = {param: 'test'}
                test_data = {param: 'test'} if endpoint_path in ['/login', '/user/login', '/auth/login'] else None

                method = 'POST' if test_data else 'GET'

                try:
                    vulns = self.scan_endpoint(
                        endpoint=full_url,
                        method=method,
                        params=test_params if method == 'GET' else None,
                        data=test_data if method == 'POST' else None,
                        analyzers=analyzers
                    )
                    vulnerabilities.extend(vulns)

                except Exception as e:
                    self.logger.debug(f"Failed to scan {full_url}: {e}")

        return vulnerabilities

    def generate_report(self, output_dir: str = None,
                       format: str = 'json') -> str:
        """
        生成扫描报告

        Args:
            output_dir: 输出目录
            format: 报告格式 (json, html, both)

        Returns:
            报告文件路径
        """
        output_dir = output_dir or self.config.OUTPUT_DIR
        os.makedirs(output_dir, exist_ok=True)

        # 生成文件名
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        domain = self.target.replace('https://', '').replace('http://', '').replace('/', '_')

        report_paths = []

        if format in ('json', 'both'):
            json_path = os.path.join(output_dir, f'{domain}_{timestamp}.json')
            reporter = JSONReporter(self.poc_recorder)
            reporter.generate(json_path, self.target)
            report_paths.append(json_path)
            self.logger.info(f"JSON report saved to: {json_path}")

        if format in ('html', 'both'):
            html_path = os.path.join(output_dir, f'{domain}_{timestamp}.html')
            reporter = HTMLReporter(self.poc_recorder)
            reporter.generate(html_path, self.target)
            report_paths.append(html_path)
            self.logger.info(f"HTML report saved to: {html_path}")

        return report_paths[0] if len(report_paths) == 1 else report_paths

    def cleanup(self):
        """清理资源"""
        self.requester.close()


def main():
    """主函数"""
    parser = argparse.ArgumentParser(
        description='AutoPentest - 自动化渗透测试工具',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
示例:
  # 扫描单个端点
  python -m autopentest.main --target http://example.com --endpoint "/api/user?id=1"

  # 使用常见端点扫描
  python -m autopentest.main --target http://example.com --test-endpoints

  # 生成 HTML 报告
  python -m autopentest.main --target http://example.com --test-endpoints --report-format html

  # 指定输出目录
  python -m autopentest.main --target http://example.com --test-endpoints --output-dir ./reports
        """
    )

    parser.add_argument(
        '--target', '-t',
        required=True,
        help='目标 URL'
    )

    parser.add_argument(
        '--endpoint', '-e',
        help='要扫描的具体端点（包含参数）'
    )

    parser.add_argument(
        '--test-endpoints',
        action='store_true',
        help='使用常见测试端点进行扫描'
    )

    parser.add_argument(
        '--analyzers', '-a',
        nargs='+',
        choices=['sqli'],
        default=['sqli'],
        help='要使用的分析器（默认: sqli）'
    )

    parser.add_argument(
        '--report-format', '-r',
        choices=['json', 'html', 'both'],
        default='json',
        help='报告格式（默认: json）'
    )

    parser.add_argument(
        '--output-dir', '-o',
        help='报告输出目录（默认: ./reports）'
    )

    parser.add_argument(
        '--no-llm',
        action='store_true',
        help='禁用 LLM 分析'
    )

    args = parser.parse_args()

    # 验证配置
    config = Settings()
    if args.no_llm:
        config.ENABLE_LLM_ANALYSIS = False

    errors = config.validate()
    if errors:
        print("配置错误:")
        for error in errors:
            print(f"  - {error}")
        sys.exit(1)

    # 创建扫描器
    scanner = AutoPentest(args.target, config)

    try:
        # 执行扫描
        if args.endpoint:
            # 解析端点参数
            from urllib.parse import urlparse, parse_qs
            parsed = urlparse(args.endpoint)

            params = {}
            if parsed.query:
                for key, values in parse_qs(parsed.query).items():
                    params[key] = values[0] if values else ''

            # 构造完整 URL
            full_url = f"{args.target.rstrip('/')}{parsed.path}"
            scanner.scan_endpoint(
                endpoint=full_url,
                params=params if params else None,
                analyzers=args.analyzers
            )

        elif args.test_endpoints:
            scanner.scan_with_test_endpoints(analyzers=args.analyzers)

        else:
            print("错误: 请指定 --endpoint 或 --test-endpoints")
            parser.print_help()
            sys.exit(1)

        # 生成报告
        report_path = scanner.generate_report(
            output_dir=args.output_dir,
            format=args.report_format
        )

        # 打印摘要
        stats = scanner.poc_recorder.get_statistics()
        print(f"\n=== 扫描完成 ===")
        print(f"目标: {args.target}")
        print(f"发现漏洞: {stats['total']} 个")
        for severity, count in stats.get('by_severity', {}).items():
            print(f"  {severity}: {count}")
        print(f"报告: {report_path}")

    except KeyboardInterrupt:
        print("\n\n扫描已中断")
        sys.exit(1)

    except Exception as e:
        print(f"\n错误: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

    finally:
        scanner.cleanup()


if __name__ == '__main__':
    main()
