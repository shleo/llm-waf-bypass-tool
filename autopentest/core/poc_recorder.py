"""
PoC (Proof of Concept) Recorder module
"""
from typing import Dict, Any, Optional, List
from datetime import datetime
import json
import hashlib


class PoCRecorder:
    """
    POC 记录器，记录漏洞验证的完整请求响应
    """

    def __init__(self):
        self.pocs = []

    def record_request(self, method: str, url: str,
                       headers: Dict[str, str],
                       body: Optional[str] = None,
                       params: Optional[Dict] = None) -> Dict[str, Any]:
        """
        记录 HTTP 请求

        Args:
            method: HTTP 方法
            url: 完整 URL
            headers: 请求头字典
            body: 请求体
            params: URL 参数

        Returns:
            请求记录字典
        """
        request_record = {
            'method': method,
            'url': url,
            'headers': headers,
            'params': params or {},
            'body': body,
            'timestamp': datetime.now().isoformat()
        }

        # 生成原始 HTTP 请求格式
        request_record['raw_request'] = self._format_raw_request(
            method, url, headers, body, params
        )

        return request_record

    def record_response(self, status_code: int, headers: Dict[str, str],
                        body: str, response_time: float) -> Dict[str, Any]:
        """
        记录 HTTP 响应

        Args:
            status_code: HTTP 状态码
            headers: 响应头
            body: 响应体
            response_time: 响应时间（秒）

        Returns:
            响应记录字典
        """
        response_record = {
            'status_code': status_code,
            'headers': headers,
            'body': body,
            'body_length': len(body),
            'response_time': response_time,
            'timestamp': datetime.now().isoformat()
        }

        # 计算响应体的哈希值
        response_record['body_hash'] = hashlib.md5(
            body.encode('utf-8', errors='ignore')
        ).hexdigest()

        return response_record

    def _format_raw_request(self, method: str, url: str,
                           headers: Dict[str, str],
                           body: Optional[str] = None,
                           params: Optional[Dict] = None) -> str:
        """
        格式化为原始 HTTP 请求格式

        Args:
            method: HTTP 方法
            url: URL
            headers: 请求头
            body: 请求体
            params: URL 参数

        Returns:
            原始 HTTP 请求字符串
        """
        from urllib.parse import urlparse, urlunparse, urlencode

        parsed = urlparse(url)
        path = parsed.path

        # 添加查询参数
        if params:
            query = urlencode(params)
            if parsed.query:
                path = f"{path}?{parsed.query}&{query}"
            else:
                path = f"{path}?{query}"

        raw = f"{method} {path} HTTP/1.1\r\n"
        raw += f"Host: {parsed.netloc}\r\n"

        for key, value in headers.items():
            if key.lower() != 'host':  # Host 已经添加过了
                raw += f"{key}: {value}\r\n"

        raw += "\r\n"

        if body:
            raw += body

        return raw

    def add_vulnerability(self, vuln_type: str, severity: str,
                         endpoint: str, description: str,
                         payload: str, request_record: Dict,
                         response_record: Dict, impact: str = "",
                         remediation: str = "") -> Dict[str, Any]:
        """
        添加一个漏洞记录

        Args:
            vuln_type: 漏洞类型 (SQL Injection, RCE, etc.)
            severity: 严重程度 (CRITICAL, HIGH, MEDIUM, LOW)
            endpoint: 存在漏洞的端点
            description: 漏洞描述
            payload: 触发漏洞的 payload
            request_record: 请求记录
            response_record: 响应记录
            impact: 影响描述
            remediation: 修复建议

        Returns:
            完整的漏洞记录
        """
        vulnerability = {
            'id': self._generate_vuln_id(),
            'type': vuln_type,
            'severity': severity,
            'endpoint': endpoint,
            'description': description,
            'payload': payload,
            'request': request_record,
            'response': response_record,
            'impact': impact,
            'remediation': remediation,
            'discovered_at': datetime.now().isoformat()
        }

        self.pocs.append(vulnerability)
        return vulnerability

    def _generate_vuln_id(self) -> str:
        """生成唯一的漏洞 ID"""
        timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
        count = len(self.pocs) + 1
        return f"VULN-{timestamp}-{count:03d}"

    def get_all_vulnerabilities(self) -> List[Dict[str, Any]]:
        """获取所有发现的漏洞"""
        return self.pocs

    def get_vulnerabilities_by_severity(self, severity: str) -> List[Dict[str, Any]]:
        """按严重程度筛选漏洞"""
        return [v for v in self.pocs if v['severity'] == severity]

    def get_vulnerabilities_by_type(self, vuln_type: str) -> List[Dict[str, Any]]:
        """按类型筛选漏洞"""
        return [v for v in self.pocs if v['type'] == vuln_type]

    def clear(self):
        """清空所有记录"""
        self.pocs = []

    def export_json(self, filepath: str):
        """导出为 JSON 文件"""
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump({
                'total_vulnerabilities': len(self.pocs),
                'vulnerabilities': self.pocs
            }, f, indent=2, ensure_ascii=False)

    def get_statistics(self) -> Dict[str, Any]:
        """获取漏洞统计信息"""
        stats = {
            'total': len(self.pocs),
            'by_severity': {},
            'by_type': {}
        }

        for vuln in self.pocs:
            # 按严重程度统计
            severity = vuln['severity']
            stats['by_severity'][severity] = \
                stats['by_severity'].get(severity, 0) + 1

            # 按类型统计
            vuln_type = vuln['type']
            stats['by_type'][vuln_type] = \
                stats['by_type'].get(vuln_type, 0) + 1

        return stats
