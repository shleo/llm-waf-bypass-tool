"""
HTTP Requester module - handles all HTTP communications
"""
import requests
from typing import Dict, Any, Optional, Tuple
from urllib.parse import urljoin
import time


class Requester:
    """
    HTTP 请求封装类，处理所有与目标服务器的通信
    """

    def __init__(self, timeout: int = 10, max_retries: int = 3,
                 user_agent: str = None, proxy: Optional[str] = None):
        """
        初始化请求器

        Args:
            timeout: 请求超时时间（秒）
            max_retries: 最大重试次数
            user_agent: 自定义 User-Agent
            proxy: 代理服务器地址
        """
        self.timeout = timeout
        self.max_retries = max_retries
        self.proxy = proxy

        self.session = requests.Session()

        # 设置默认请求头
        default_headers = {
            'User-Agent': user_agent or 'AutoPentest/1.0',
            'Accept': '*/*',
            'Accept-Language': 'en-US,en;q=0.9',
        }
        self.session.headers.update(default_headers)

        if proxy:
            self.session.proxies = {
                'http': proxy,
                'https': proxy
            }

    def send_request(self, method: str, url: str,
                     params: Optional[Dict] = None,
                     data: Optional[Dict] = None,
                     json_data: Optional[Dict] = None,
                     headers: Optional[Dict] = None,
                     cookies: Optional[Dict] = None,
                     allow_redirects: bool = True) -> Tuple[requests.Response, float]:
        """
        发送 HTTP 请求

        Args:
            method: HTTP 方法 (GET, POST, PUT, DELETE, etc.)
            url: 目标 URL
            params: URL 查询参数
            data: 表单数据
            json_data: JSON 数据
            headers: 额外的请求头
            cookies: Cookies
            allow_redirects: 是否允许重定向

        Returns:
            (response, elapsed_time) 响应对象和耗时（秒）
        """
        start_time = time.time()

        for attempt in range(self.max_retries):
            try:
                response = self.session.request(
                    method=method,
                    url=url,
                    params=params,
                    data=data,
                    json=json_data,
                    headers=headers,
                    cookies=cookies,
                    allow_redirects=allow_redirects,
                    timeout=self.timeout
                )

                elapsed_time = time.time() - start_time
                return response, elapsed_time

            except requests.exceptions.Timeout:
                if attempt == self.max_retries - 1:
                    raise TimeoutError(f"Request timeout after {self.timeout}s")
                continue

            except requests.exceptions.RequestException as e:
                if attempt == self.max_retries - 1:
                    raise Exception(f"Request failed: {str(e)}")
                continue

    def get(self, url: str, params: Optional[Dict] = None,
            headers: Optional[Dict] = None,
            cookies: Optional[Dict] = None) -> Tuple[requests.Response, float]:
        """发送 GET 请求"""
        return self.send_request('GET', url, params=params,
                                 headers=headers, cookies=cookies)

    def post(self, url: str, data: Optional[Dict] = None,
             json_data: Optional[Dict] = None,
             headers: Optional[Dict] = None,
             cookies: Optional[Dict] = None) -> Tuple[requests.Response, float]:
        """发送 POST 请求"""
        return self.send_request('POST', url, data=data, json_data=json_data,
                                 headers=headers, cookies=cookies)

    def extract_base_url(self, url: str) -> str:
        """从完整 URL 中提取基础 URL"""
        from urllib.parse import urlparse
        parsed = urlparse(url)
        return f"{parsed.scheme}://{parsed.netloc}"

    def close(self):
        """关闭 session"""
        self.session.close()
